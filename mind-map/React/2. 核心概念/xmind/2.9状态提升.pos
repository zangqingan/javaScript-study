{"diagram":{"image":{"x":0,"width":200,"y":0,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","height":200},"elements":{"leftChildren":[],"note":"","margin":{"childMarginW":10,"childMarginH":5,"marginW":20,"marginH":10},"watermark":"","children":[{"parent":"root","lineStyle":{"randomLineColor":"rgb(255,204,204)","lineColor":"#7B1FA2"},"children":[{"parent":"812b3a9306dd","note":"","children":[],"style":{"color":"#9C27B0","font-weight":"normal"},"id":"ac25a09c6779","title":"通常，多个组件需要反映相同的变化数据，这时我们建议将共享状态提升到最近的共同父组件中去<br>","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"812b3a9306dd","children":[],"id":"4d70d73dad33","title":"例如，创建一个用于计算水在给定温度下是否会沸腾的温度计算器","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"1","text":"&#xe625"}]},{"parent":"812b3a9306dd","note":"function BoilingVerdict(props) {\n  if (props.celsius &gt;= 100) {\n    return &lt;p&gt;The water would boil.&lt;/p&gt;;\n  }\n  return &lt;p&gt;The water would not boil.&lt;/p&gt;;\n}","children":[],"id":"c4c8ddf71cd2","title":"我们将从一个名为&nbsp;BoilingVerdict&nbsp;的组件开始，它接受&nbsp;celsius&nbsp;温度作为一个&nbsp;prop，并据此打印出该温度是否足以将水煮沸的结果","icons":[{"color":"rgb(113, 203, 45)","name":"priority","index":"2","text":"&#xe62a"}]},{"parent":"812b3a9306dd","note":"class Calculator extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n    this.state = {temperature: &#39;&#39;};\n  }\n\n  handleChange(e) {\n    this.setState({temperature: e.target.value});\n  }\n\n  render() {\n    const temperature = this.state.temperature;\n    return (\n      &lt;fieldset&gt;\n        &lt;legend&gt;Enter temperature in Celsius:&lt;/legend&gt;\n        &lt;input\n          value={temperature}\n          onChange={this.handleChange} /&gt;\n        &lt;BoilingVerdict\n          celsius={parseFloat(temperature)} /&gt;\n      &lt;/fieldset&gt;\n    );\n  }\n}\n","children":[],"id":"0ea413d23ee5","title":"接下来,&nbsp;我们创建一个名为&nbsp;Calculator&nbsp;的组件。它渲染一个用于输入温度的&nbsp;&lt;input&gt;，并将其值保存在&nbsp;this.state.temperature&nbsp;中。<br>另外,&nbsp;它根据当前输入值渲染&nbsp;BoilingVerdict&nbsp;组件","icons":[{"color":"rgb(255, 159, 26)","name":"priority","index":"3","text":"&#xe635"}]}],"style":{"background-color":"#7B1FA2","border-radius":"5px","color":"rgb(255, 255, 255)","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"812b3a9306dd","title":"简介"},{"parent":"root","lineStyle":{"lineColor":"#1976D2","lineWidth":"2"},"children":[{"parent":"c723a9675abe","note":"const scaleNames = {\n  c: &#39;Celsius&#39;,\n  f: &#39;Fahrenheit&#39;\n};\n\nclass TemperatureInput extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n    this.state = {temperature: &#39;&#39;};\n  }\n\n  handleChange(e) {\n    this.setState({temperature: e.target.value});\n  }\n\n  render() {\n    const temperature = this.state.temperature;\n    const scale = this.props.scale;\n    return (\n      &lt;fieldset&gt;\n        &lt;legend&gt;Enter temperature in {scaleNames[scale]}:&lt;/legend&gt;\n        &lt;input value={temperature}\n               onChange={this.handleChange} /&gt;\n      &lt;/fieldset&gt;\n    );\n  }\n}","children":[],"id":"6c3908c4ee07","title":"我们的新需求是，在已有摄氏温度输入框的基础上，我们提供华氏度的输入框，并保持两个输入框的数据同步。<br>我们先从&nbsp;Calculator&nbsp;组件中抽离出&nbsp;TemperatureInput&nbsp;组件，然后为其添加一个新的&nbsp;scale&nbsp;prop，它可以是&nbsp;\"c\"&nbsp;或是&nbsp;\"f\"","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"c723a9675abe","note":"class Calculator extends React.Component {\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;TemperatureInput scale=&quot;c&quot; /&gt;\n        &lt;TemperatureInput scale=&quot;f&quot; /&gt;\n      &lt;/div&gt;\n    );\n  }\n}","children":[],"id":"a53c6f2ec719","title":"我们现在可以修改&nbsp;Calculator&nbsp;组件让它渲染两个独立的温度输入框组件","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"1","text":"&#xe625"}]},{"parent":"c723a9675abe","children":[],"id":"290074f61aa6","title":"现在有了两个输入框，但当你在其中一个输入温度时，另一个并不会更新。这与我们的要求相矛盾：我们希望让它们保持同步","icons":[{"color":"rgb(113, 203, 45)","name":"priority","index":"2","text":"&#xe62a"}]},{"parent":"c723a9675abe","children":[],"id":"8c658118ae96","title":"另外，我们也不能通过&nbsp;Calculator&nbsp;组件展示&nbsp;BoilingVerdict&nbsp;组件的渲染结果。<br>因为&nbsp;Calculator&nbsp;组件并不知道隐藏在&nbsp;TemperatureInput&nbsp;组件中的当前温度是多少","icons":[{"color":"rgb(255, 159, 26)","name":"priority","index":"3","text":"&#xe635"}]}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"#F5F5F5","textAlign":"left","font-weight":"bold","font-size":13,"font-style":"normal","border-radius":"5px","background-color":"#1976D2","lineStype":{"lineColor":"#1976D2","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#1976D2","lineWidth":"2"},"font-family":"微软雅黑","border-width":0,"border-style":"solid"},"id":"c723a9675abe","title":"添加第二个输入框"},{"parent":"root","lineStyle":{"lineColor":"#388E3C","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"children":[{"parent":"a366ed307a4a","note":"function toCelsius(fahrenheit) {\n  return (fahrenheit - 32) * 5 / 9;\n}\n\nfunction toFahrenheit(celsius) {\n  return (celsius * 9 / 5) + 32;\n}","children":[],"id":"e63f6a4fdc87","title":"首先，我们将编写两个可以在摄氏度与华氏度之间相互转换的函数","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"a366ed307a4a","note":"function tryConvert(temperature, convert) {\n  const input = parseFloat(temperature);\n  if (Number.isNaN(input)) {\n    return &#39;&#39;;\n  }\n  const output = convert(input);\n  const rounded = Math.round(output * 1000) / 1000;\n  return rounded.toString();\n}","children":[],"id":"3d5836eb38b6","title":"上述两个函数仅做数值转换。而我们将编写另一个函数，它接受字符串类型的&nbsp;temperature&nbsp;和转换函数作为参数并返回一个字符串。<br>我们将使用它来依据一个输入框的值计算出另一个输入框的值","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"1","text":"&#xe625"}]}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"rgb(255, 255, 255)","textAlign":"left","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","font-style":"normal","border-radius":"5px","background-color":"#388E3C","lineStype":{"lineColor":"#388E3C","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#388E3C","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"font-family":"微软雅黑","border-width":"0px","border-style":"none"},"id":"a366ed307a4a","title":"编写转换函数"},{"parent":"root","lineStyle":{"lineColor":"#F57F17","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"children":[{"parent":"2a8881dc4152","note":"","children":[],"id":"d79e61d3727d","title":"到目前为止,&nbsp;两个&nbsp;TemperatureInput&nbsp;组件均在各自内部的&nbsp;state&nbsp;中相互独立地保存着各自的数据","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"2a8881dc4152","children":[],"id":"39826500071d","title":"然而，我们希望两个输入框内的数值彼此能够同步。当我们更新摄氏度输入框内的数值时，华氏度输入框内应当显示转换后的华氏温度，反之亦然","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"1","text":"&#xe625"}]},{"parent":"2a8881dc4152","children":[],"style":{"color":"#E65100","font-weight":"bold"},"id":"68af52203073","title":"在&nbsp;React&nbsp;中，将多个组件中需要共享的&nbsp;state&nbsp;向上移动到它们的最近共同父组件中，便可实现共享&nbsp;state。这就是所谓的“状态提升”","icons":[{"color":"rgb(113, 203, 45)","name":"priority","index":"2","text":"&#xe62a"}]},{"parent":"2a8881dc4152","children":[],"id":"133861172d71","title":"接下来，我们将&nbsp;TemperatureInput&nbsp;组件中的&nbsp;state&nbsp;移动至&nbsp;Calculator&nbsp;组件中去。<br>如果&nbsp;Calculator&nbsp;组件拥有了共享的&nbsp;state，它将成为两个温度输入框中当前温度的“数据源”。它能够使得两个温度输入框的数值彼此保持一致。由于两个&nbsp;TemperatureInput&nbsp;组件的&nbsp;props&nbsp;均来自共同的父组件&nbsp;Calculator，因此两个输入框中的内容将始终保持一致。<br>让我们看看这是如何一步一步实现的","icons":[{"color":"rgb(255, 159, 26)","name":"priority","index":"3","text":"&#xe635"}]},{"parent":"2a8881dc4152","note":"  render() {\n    // Before: const temperature = this.state.temperature;\n    const temperature = this.props.temperature;\n    // ...","children":[],"id":"e8227b5e049e","title":"首先，我们将&nbsp;TemperatureInput&nbsp;组件中的&nbsp;this.state.temperature&nbsp;替换为&nbsp;this.props.temperature。现在，我们先假定&nbsp;this.props.temperature&nbsp;已经存在，尽管将来我们需要通过&nbsp;Calculator&nbsp;组件将其传入","icons":[]},{"parent":"2a8881dc4152","children":[],"id":"f8feab9b3eb5","title":"我们知道&nbsp;props&nbsp;是只读的。当&nbsp;temperature&nbsp;存在于&nbsp;TemperatureInput&nbsp;组件的&nbsp;state&nbsp;中时，组件调用&nbsp;this.setState()&nbsp;便可修改它。然而，temperature&nbsp;是由父组件传入的&nbsp;prop，TemperatureInput&nbsp;组件便失去了对它的控制权"},{"parent":"2a8881dc4152","children":[],"id":"47cc1a3e3bde","title":"在&nbsp;React&nbsp;中，这个问题通常是通过使用“受控组件”来解决的。与&nbsp;DOM&nbsp;中的&nbsp;&lt;input&gt;&nbsp;接受&nbsp;value&nbsp;和&nbsp;onChange&nbsp;一样，自定义的&nbsp;TemperatureInput&nbsp;组件接受&nbsp;temperature&nbsp;和&nbsp;onTemperatureChange&nbsp;这两个来自父组件&nbsp;Calculator&nbsp;的&nbsp;props"},{"parent":"2a8881dc4152","note":" handleChange(e) {\n    // Before: this.setState({temperature: e.target.value});\n    this.props.onTemperatureChange(e.target.value);\n    // ...","children":[],"id":"08b23d82dd40","title":"现在，当&nbsp;TemperatureInput&nbsp;组件想更新温度时，需调用&nbsp;this.props.onTemperatureChange&nbsp;来更新它"},{"parent":"2a8881dc4152","children":[],"id":"a6efad40f5c7","title":"onTemperatureChange&nbsp;的&nbsp;prop&nbsp;和&nbsp;temperature&nbsp;的&nbsp;prop&nbsp;一样，均由父组件&nbsp;Calculator&nbsp;提供。它通过修改父组件自身的内部&nbsp;state&nbsp;来处理数据的变化，进而使用新的数值重新渲染两个输入框。我们将很快看到修改后的&nbsp;Calculator&nbsp;组件效果"},{"parent":"2a8881dc4152","note":"class TemperatureInput extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n  }\n\n  handleChange(e) {\n    this.props.onTemperatureChange(e.target.value);\n  }\n\n  render() {\n    const temperature = this.props.temperature;\n    const scale = this.props.scale;\n    return (\n      &lt;fieldset&gt;\n        &lt;legend&gt;Enter temperature in {scaleNames[scale]}:&lt;/legend&gt;\n        &lt;input value={temperature}\n               onChange={this.handleChange} /&gt;\n      &lt;/fieldset&gt;\n    );\n  }\n}","children":[],"id":"7dd591066202","title":"在深入研究&nbsp;Calculator&nbsp;组件的变化之前，让我们回顾一下&nbsp;TemperatureInput&nbsp;组件的变化。我们移除组件自身的&nbsp;state，通过使用&nbsp;this.props.temperature&nbsp;替代&nbsp;this.state.temperature&nbsp;来读取温度数据。当我们想要响应数据改变时，我们需要调用&nbsp;Calculator&nbsp;组件提供的&nbsp;this.props.onTemperatureChange()，而不再使用&nbsp;this.setState()"},{"parent":"2a8881dc4152","children":[],"id":"44f9de43a783","title":"现在，让我们把目光转向&nbsp;Calculator&nbsp;组件。我们会把当前输入的&nbsp;temperature&nbsp;和&nbsp;scale&nbsp;保存在组件内部的&nbsp;state&nbsp;中。这个&nbsp;state&nbsp;就是从两个输入框组件中“提升”而来的，并且它将用作两个输入框组件的共同“数据源”。这是我们为了渲染两个输入框所需要的所有数据的最小表示"},{"parent":"2a8881dc4152","note":"class Calculator extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleCelsiusChange = this.handleCelsiusChange.bind(this);\n    this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this);\n    this.state = {temperature: &#39;&#39;, scale: &#39;c&#39;};\n  }\n\n  handleCelsiusChange(temperature) {\n    this.setState({scale: &#39;c&#39;, temperature});\n  }\n\n  handleFahrenheitChange(temperature) {\n    this.setState({scale: &#39;f&#39;, temperature});\n  }\n\n  render() {\n    const scale = this.state.scale;\n    const temperature = this.state.temperature;\n    const celsius = scale === &#39;f&#39; ? tryConvert(temperature, toCelsius) : temperature;\n    const fahrenheit = scale === &#39;c&#39; ? tryConvert(temperature, toFahrenheit) : temperature;\n\n    return (\n      &lt;div&gt;\n        &lt;TemperatureInput\n          scale=&quot;c&quot;\n          temperature={celsius}\n          onTemperatureChange={this.handleCelsiusChange} /&gt;\n        &lt;TemperatureInput\n          scale=&quot;f&quot;\n          temperature={fahrenheit}\n          onTemperatureChange={this.handleFahrenheitChange} /&gt;\n        &lt;BoilingVerdict\n          celsius={parseFloat(celsius)} /&gt;\n      &lt;/div&gt;\n    );\n  }\n}","children":[],"id":"5cc8410a2e7c","title":"我们可以存储两个输入框中的值，但这并不是必要的。我们只需要存储最近修改的温度及其计量单位即可，根据当前的&nbsp;temperature&nbsp;和&nbsp;scale&nbsp;就可以计算出另一个输入框的值。<br>由于两个输入框中的数值由同一个&nbsp;state&nbsp;计算而来，因此它们始终保持同步："},{"parent":"2a8881dc4152","children":[],"id":"f14c6b304a05","title":"现在无论你编辑哪个输入框中的内容，Calculator&nbsp;组件中的&nbsp;this.state.temperature&nbsp;和&nbsp;this.state.scale&nbsp;均会被更新。其中一个输入框保留用户的输入并取值，另一个输入框始终基于这个值显示转换后的结果"}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"rgb(255, 255, 255)","textAlign":"left","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","font-style":"normal","border-radius":"5px","background-color":"#F57F17","lineStype":{"lineColor":"#F57F17","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#F57F17","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"font-family":"微软雅黑","border-width":"0px","border-style":"none"},"id":"2a8881dc4152","title":"状态提升"},{"parent":"root","lineStyle":{"lineColor":"#E57373","lineWidth":"2"},"children":[{"parent":"7f3589238824","children":[],"id":"600655f3f332","title":"让我们来重新梳理一下当你对输入框内容进行编辑时会发生些什么："},{"parent":"7f3589238824","children":[],"id":"cfe6125cb6b2","title":"React&nbsp;会调用&nbsp;DOM&nbsp;中&nbsp;&lt;input&gt;&nbsp;的&nbsp;onChange&nbsp;方法。在本实例中，它是&nbsp;TemperatureInput&nbsp;组件的&nbsp;handleChange&nbsp;方法。"},{"parent":"7f3589238824","children":[],"id":"42c1a56be0b0","title":"TemperatureInput&nbsp;组件中的&nbsp;handleChange&nbsp;方法会调用&nbsp;this.props.onTemperatureChange()，并传入新输入的值作为参数。其&nbsp;props&nbsp;诸如&nbsp;onTemperatureChange&nbsp;之类，均由父组件&nbsp;Calculator&nbsp;提供。"},{"parent":"7f3589238824","children":[],"id":"a0a13fdb32fb","title":"起初渲染时，用于摄氏度输入的子组件&nbsp;TemperatureInput&nbsp;中的&nbsp;onTemperatureChange&nbsp;方法与&nbsp;Calculator&nbsp;组件中的&nbsp;handleCelsiusChange&nbsp;方法相同，而，用于华氏度输入的子组件&nbsp;TemperatureInput&nbsp;中的&nbsp;onTemperatureChange&nbsp;方法与&nbsp;Calculator&nbsp;组件中的&nbsp;handleFahrenheitChange&nbsp;方法相同。因此，无论哪个输入框被编辑都会调用&nbsp;Calculator&nbsp;组件中对应的方法。"},{"parent":"7f3589238824","children":[],"id":"0bfe1157fa34","title":"在这些方法内部，Calculator&nbsp;组件通过使用新的输入值与当前输入框对应的温度计量单位来调用&nbsp;this.setState()&nbsp;进而请求&nbsp;React&nbsp;重新渲染自己本身。"},{"parent":"7f3589238824","children":[],"id":"6428d751b6b9","title":"React&nbsp;调用&nbsp;Calculator&nbsp;组件的&nbsp;render&nbsp;方法得到组件的&nbsp;UI&nbsp;呈现。温度转换在这时进行，两个输入框中的数值通过当前输入温度和其计量单位来重新计算获得。"},{"parent":"7f3589238824","children":[],"id":"f67bb66b4213","title":"React&nbsp;使用&nbsp;Calculator&nbsp;组件提供的新&nbsp;props&nbsp;分别调用两个&nbsp;TemperatureInput&nbsp;子组件的&nbsp;render&nbsp;方法来获取子组件的&nbsp;UI&nbsp;呈现。"},{"parent":"7f3589238824","children":[],"id":"944ad69ead88","title":"React&nbsp;调用&nbsp;BoilingVerdict&nbsp;组件的&nbsp;render&nbsp;方法，并将摄氏温度值以组件&nbsp;props&nbsp;方式传入。"},{"parent":"7f3589238824","children":[],"id":"7ada81747a8d","title":"React&nbsp;DOM&nbsp;根据输入值匹配水是否沸腾，并将结果更新至&nbsp;DOM。我们刚刚编辑的输入框接收其当前值，另一个输入框内容更新为转换后的温度值。"}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"#F5F5F5","textAlign":"left","font-weight":"bold","font-size":13,"font-style":"normal","border-radius":"5px","background-color":"#E57373","lineStype":{"lineColor":"#E57373","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#E57373","lineWidth":"2"},"font-family":"微软雅黑","border-width":0,"border-style":"solid"},"id":"7f3589238824","title":"梳理"},{"parent":"root","lineStyle":{"lineColor":"#2196F3","lineWidth":"2"},"children":[{"parent":"e9477773125e","note":"","children":[],"id":"c4151b2c2cc2","title":"在&nbsp;React&nbsp;应用中，任何可变数据应当只有一个相对应的唯一“数据源”。通常，state&nbsp;都是首先添加到需要渲染数据的组件中去。然后，如果其他组件也需要这个&nbsp;state，那么你可以将它提升至这些组件的最近共同父组件中。你应当依靠自上而下的数据流，而不是尝试在不同组件间同步&nbsp;state","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"e9477773125e","children":[],"id":"f46d353ad051","title":"虽然提升&nbsp;state&nbsp;方式比双向绑定方式需要编写更多的“样板”代码，但带来的好处是，排查和隔离&nbsp;bug&nbsp;所需的工作量将会变少。由于“存在”于组件中的任何&nbsp;state，仅有组件自己能够修改它，因此&nbsp;bug&nbsp;的排查范围被大大缩减了。此外，你也可以使用自定义逻辑来拒绝或转换用户的输入","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"1","text":"&#xe625"}]},{"parent":"e9477773125e","children":[],"id":"c860d231fa6a","title":"如果某些数据可以由&nbsp;props&nbsp;或&nbsp;state&nbsp;推导得出，那么它就不应该存在于&nbsp;state&nbsp;中。举个例子，本例中我们没有将&nbsp;celsiusValue&nbsp;和&nbsp;fahrenheitValue&nbsp;一起保存，而是仅保存了最后修改的&nbsp;temperature&nbsp;和它的&nbsp;scale。这是因为另一个输入框的温度值始终可以通过这两个值以及组件的&nbsp;render()&nbsp;方法获得。这使得我们能够清除输入框内容，亦或是，在不损失用户操作的输入框内数值精度的前提下对另一个输入框内的转换数值做四舍五入的操作","icons":[{"color":"rgb(113, 203, 45)","name":"priority","index":"2","text":"&#xe62a"}]},{"parent":"e9477773125e","children":[],"id":"b4cdda29f99b","title":"当你在&nbsp;UI&nbsp;中发现错误时，可以使用&nbsp;React&nbsp;开发者工具&nbsp;来检查问题组件的&nbsp;props，并且按照组件树结构逐级向上搜寻，直到定位到负责更新&nbsp;state&nbsp;的那个组件。这使得你能够追踪到产生&nbsp;bug&nbsp;的源头","icons":[{"color":"rgb(255, 159, 26)","name":"priority","index":"3","text":"&#xe635"}]}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"#F5F5F5","textAlign":"left","font-weight":"bold","font-size":"14px","font-style":"normal","border-radius":"5px","lineStype":{"lineColor":"#2196F3","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#2196F3","lineWidth":"2"},"font-family":"微软雅黑","border-width":0,"border-style":"solid"},"id":"e9477773125e","title":"学习小结"}],"root":true,"theme":"customise_7fd055efa78b","style":{"font-weight":"bold"},"id":"root","title":"状态提升","icons":[{"color":"rgb(255, 255, 255)","name":"","index":"38"}],"structure":"mind_free"}},"meta":{"exportTime":"2022-04-01 23:56:49","member":"60cca488e0b34d55bbf2954f","diagramInfo":{"creator":"60cca488e0b34d55bbf2954f","created":"2022-04-01 23:23:43","modified":"2022-04-01 23:56:07","title":"2.9状态提升","category":"mind_free"},"id":"624718ff0791290709715a71","type":"ProcessOn Schema File","version":"1.0"}}