<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>JavaScript对象Object</title>
    <link href="../../assets//styles/index.css" rel="stylesheet"></link>
</head>
<body>
    <div class="content">
        <h3>1、js对象的概述</h3>
        <div>
            <h4>1.js对象的定义</h4>
            <div>
                对象就是现实事物在计算机程序语言中的抽象表示,在JavaScript 中其实所有事物都是对象:字符串、数字、数组、日期,等等。
                而且JavaScript 的所有其他对象都继承自Object对象,即那些对象都是Object的实例。<br>
                对象是一种复合的引用数据类型,它可以保存多个不同数据类型的变量,这些变量也叫做属性或方法。就像一个袋子或者说一个容器或者说一张无序的表一样。
                属性是与对象相关的值,方法是能够在对象上执行的动作。在面向对象的语言中,属性和方法常被称为对象的成员。
                在js对象中都是以名值对形式存在(key-value)的无序的复合数据集合,名字也叫“属性”(property),<br>
                注意:名值对之间用逗号分隔,属性名是字符串时可以不用逗号括起来,而属性值是字符串类型时必须用双引号括起来。
                如果一个属性的值为函数,通常把这个属性称为“方法”,它可以像函数那样调用。
                <pre>
                    {
                        属性名:属性值,
                        name:"zhangsan",
                        age:25,
                        sayHi:function(){...}
                    }
                </pre>
                注意:属性名和属性值的要求
                    属性名都是字符串或者符号类型同时应遵守js标识符的命名规则且应尽量语义化,对于特殊的属性名不能使用 对象.属性名 的方式访问操作。<br>
                    而是应该使用 对象[属性名] 来操作。
                    属性值可以是除undefined值之外的任何值,即其它任意的 js数据类型(也可以是另一个对象这时就是嵌套了)
                <br> 
                <b>js对象特性:</b>js对象都有自由扩展属性的特性,即object.新属性名 = 属性值;而不是必须在声明对象时同时声明所有的属性。
            </div>
            <h4>2.js对象的分类</h4>
            <div>
                主要就是两种: 内置对象和自定义对象。
                内置对象:由ecmascript标准中定义的对象,如Math,String等
                宿主对象:由js的运行环境即浏览器提供的对象,主要是BOM和DOM.
                自定义对象:由开发人员自己创建的对象(最难最重要)
            </div>
            <h4>3.js对象属性的操作</h4>
            <div>
                <h5>1.属性的增删改查</h5>
                <p>
                    
                    在js中读取对象的属性,有两种方法,一种是使用点运算符 . ,还有一种是使用方括号运算符 [] (属性是变量或者不易表达的值就使用)。<br>
                    优先考虑使用 . 点运算符来操作(增删改查)对象的属性。<br>
                    <pre>
                        增:通过赋值语句来增加,如果之前有就覆盖久的值,没有就添加为新的属性。对象.要增加的属性名 = 对应的属性值;
                        删:delete 对象.要删除的属性名;删除成功后返回true,只能删除对象本身的属性,无法删除继承的属性
                        改:重新调用赋值语句就行,对象.要修改的属性名 = 新修改的值;
                        查:对象.要查找的属性名 或者 对象["属性名"], 查找到了返回的是属性名对应的属性值,查找不到返回undefined。
                        经常使用的定义与赋值方法
                        obj.prop =value
                        obj['prop']=value,
                        此外还有Object.defineProperty()方法。
                        var obj = {
                            p: 'Hello World'
                        };
                        obj.p // "Hello World"
                        obj['p'] // "Hello World"
                    </pre>
                </p>
                <h5>2.属性的遍历</h5>
                <p>
                    1.for in 循环,通过利用in操作符在循环中把对象的属性遍历处理,可以定义一个数组接收遍历的属性名。
                    所有可枚举属性包括实例属性和原型属性。
                    <pre>
                        function Person(){}
                        Person.prototype.name ="zhangsan";
                        Person.prototype.age = 27;
                        Person.prototype.gender = "male";
                        Person.prototype.city = "guangzhou";
                        Person.prototype.sayName = function(){
                            console.log(this.name)
                        };
                        let person = new Person();
                        person.name = "lisi";
                        person.age = 22;
                        person.gender = "female";
                        // for in
                        let arr = []//定义一个数组接收遍历的对象属性 
                        for(let i in person){
                            arr.push(i)
                            结合 hasOwnProperty 方法可以判断这个属性是不是对象自身的属性而不是继承的属性。
                            if (person.hasOwnProperty(key)) {
                                console.log(key);
                              }
                        
                        }
                        console.log('arr is',arr)//arr is Array(5) [ "name", "age", "gender", "city", "sayName" ]
                    </pre>

                    2. Object.keys(),接收一个对象作为参数,返回一个包含该实例对象自身所有可枚举的属性名称的字符串数组。
                    <pre>
                        const result = Object.keys(person)
                        console.log('result is',result)//result is Array(3) [ "name", "age", "gender" ]
                    </pre>

                    3. Object.getOwnPropertyNames(),接收一个对象作为参数,返回一个包含所有实例属性无论是否可以枚举的(即所有的包括可枚举、不可枚举)属性名称的字符串数组。
                    很少用、基本上使用 Object.keys() 就行。
                    <pre>
                        const otherResult = Object.getOwnPropertyNames(person)
                        console.log('otherResult is',otherResult)//result is Array(3) [ "name", "age", "gender" ]
                    </pre>
                    es8之后又新增了两个迭代的静态方法,它们都接收一个对象,返回对应的内容数组。
                    Object.values()返回对象值的数组, Object.entries()返回键值对的二维数组。

                    4. Object.values(),接收一个对象作为参数,返回一个包含该实例对象所有可枚举的属性名对应的属性值字符串数组。
                    <pre>
                        const valusResult = Object.values(person)
                        console.log('valusResult is',valusResult)//valusResult is Array(3) [ "lisi", 22, "female" ]
                    </pre>

                    5. Object.entries(),接收一个对象作为参数,返回一个包含该实例对象所有可枚举键值对组成的二维字符串数组。
                    <pre>
                        const entriesResult = Object.entries(person)
                        console.log('entriesResult is',entriesResult)//entriesResult is[[ "name", "lisi" ],[ "age", 22 ],[ "gender", "female" ]]
                    </pre>
                </p>
            </div>
            <h4>4.js对象的增强语法</h4>
            <div>
                ECMAScript6为定义和操作对象新增了很多极其有用的语法特性,极大的提升了处理对象的方便程度。
                特别是属性的简写对于函数的返回值、模块的导出都是非常简洁的。
                <h5>1.属性值简写</h5>
                <p>
                    如果一个对象中属性名和属性值(属性值是一个变量)一样(key值和value值一样)则可以简写,写一个就好。
                    这时、属性名就是变量名、属性值就是变量值。
                    <pre>
                        es5:
                        let name = "zhangsan";
                        let person = {
                            name:name
                        }
                        es6:
                        let name = "zhangsan";
                        let person = {
                            name
                        }
                    </pre>

                </p>
                <h5>2.可计算属性</h5>
                <p>
                    在es5里使用变量作为属性名,需要使用中括号语法来添加。
                    而在es6增强之后可以使用可计算属性直接在对象字面量中定义动态属性。也是使用中括号告诉浏览器里面的是JavaScript表达式而不是字符串。
                    <pre>
                        es5: 
                        let nameKey = "zhangsan";
                        let person = {}
                        person[nameKey] = "lisi"<br>
                        es6: 
                        let nameKey = "zhangsan";
                        let person = {
                            [nameKey]:'lisi'
                        }
                        person[nameKey] = "lisi"
                    </pre>

                </p>
                <h5>3.方法名的简写</h5>
                <p>
                    es5时给对象定义方法时,一般都是方法名:匿名函数表达式,如下:
                    <pre>
                        let person = {
                            sayName:function(name){
                                console.log(`my name is ${name}`)
                            },
                            get:function(){},
                            set:function(val){}
                        }
                        person.sayName('zhangsan');my name is zhangsan  <br> 
                        es6: 不用再使用匿名函数表达式了,对获取和设置函数也适用,与可计算属性也相互兼容,直接写函数名即可。
                        let meKey = 'sayHi'
                        let person = {
                            sayName(name){
                                console.log(`my name is ${name}`)
                            },
                            get name(){},
                            set name(name){},//这里的name函数名是根据实际取的属性自己定义的。
                            [meKey](name){
                                console.log(`hi ${name}`)
                            }
                        }
                        person.sayName('zhangsan');my name is zhangsan 
                        实例：
                        let birth = '2000/01/01';
                        const Person = {
                            name: '张三',
                            //等同于birth: birth
                            birth,
                            // 等同于hello: function ()...
                            hello() { console.log('我的名字是', this.name); }
                        };
                    </pre>
                </p>
                <h5>4.对象的解构和扩展: 扩展(三点)运算符...</h5>
                <pre>
                    在es5中对变量赋值是使用 '=' ,且如果是要把对象的属性或者数组的元素赋值给变量只能一个一个赋值。
                    所以在es6中提供了对赋值运算符(=)的扩展即：解构赋值。
                    所谓解构(Destructuring)赋值是指按照一定模式,按照对应位置从数组或对象中提取值,并将其赋值给变量。
                    
                    解构赋值的规则是:解构源如果不是对象或数组,就先将其转为对象,undefined和null无法转为对象解构报错。<br>
                    解构模型: let {解构的目标} =  解构的源     
                        解构的源,解构赋值表达式的右边部分。<br>
                        解构的目标,解构赋值表达式的左边部分。<br>
                    优点:在代码书写上简洁且易读,语义更加清晰明了也方便了复杂对象或数组中数据字段获取。
                    对象的解构不同于数组的解构是按元素下标(index)排列的,对象的解构赋值是根据对象的属性名来一一对应的与顺序无关。<br>
                    接收变量必须与对象的属性同名,数组的解构一样,解构失败,变量值为undefined,也可以嵌套,不完全解构,或者加默认值。<br>
                    基本对象: <br>
                        obj = { username: 'zhangsan', age: 25 }<br>
                        let { username, age} = obj <br>
                        let { username, age} = { username: 'zhangsan', age: 25 }<br>
                        username // zhangsan<br>
                        age // 25<br>
                    es5是这样赋值的:<br>
                        var username= obj.username<br>
                        var age= obj.age<br>
                    或者通过键名取值<br>
                        var username= obj["username"]<br>
                        var age= obj["age"]<br>
                    注意:对象的解构赋值是es6中对象的扩展,当属性名和值同名时可以只写一个<br>
                        let { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' };<br>
                    可以简写成下面,找对象中有没有foo属性有则将它的值赋值给foo变量所以可以这样使用<br>
                        let { foo, bar } = { foo: 'aaa', bar: 'bbb' };<br>
                    本质是:在对象中找有没有foo属性,有则将属性名对应的属性值赋值给别名变量myfoo。真正被赋值的是变量而不是解构模式<br>
                        let { foo: myfoo(别名), bar: mybar } = { foo: 'aaa', bar: 'bbb' };<br>
                    注意:所有可以被遍历的对象都是可以被解构赋值的,也常常和res运算符(即... 三点运算符)一起使用。
                </pre>
                <p>
                    对象的结构用于从一个对象中取值、然后赋值给其它变量(这里的赋值是浅拷贝)、一般是和对象的增强语法属性简写一起使用。这样解构出来就可以直接使用,而不用通过 .点运算符操作。
                    特别是在模块系统中、和后端接口返回数据时解构是非常常见的。还有一个是剩余操作、即将在解构时除了已解构变量剩余的其它变量放到一个参数对象里。
                    <pre> 
                        输入模块的指定方法,加载模块时,往往需要指定输入哪些方法。非常常用！！！
                        解构赋值使得输入语句非常清晰:
                        const { SourceMapConsumer, SourceNode } = require("source-map");
                        import {SourceMapConsumer, SourceNode} from '/source-map'
                        let {name:Rename,age,gender} = peopleObj
                        let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
                        x // 1
                        y // 2
                        z // { a: 3, b: 4 }
                        从函数返回多个值(返回数组或对象),通过解构赋值直接取出来也比较常用
                        // 返回一个数组
                        function example() {
                            return [1, 2, 3];
                        }
                        let [a, b, c] = example();
        
                        // 返回一个对象
                        function example() {
                            return {
                                foo: 1,
                                bar: 2
                            };
                        }
                        let { foo, bar } = example();
                    </pre>
                    扩展运算符... ES2018 将这个运算符引入了对象。
                    对已知对象使用扩展运算符 ... 则会取出参数对象自身的、可枚举的所有属性,浅拷贝到当前对象之中。跟剩余操作相反。
                    <pre>
                        let obj1 = { a: 1, b: 2 };
                        let obj2 = { name:"wang",...obj1, c: 3 }; 
                        let obj3 = { ...obj1,name:"wang"}; 
                        console.log('obj1 is',obj1) obj1 is { a: 1, b: 2 }
                        console.log('obj2 is',obj2) obj2 is { name: 'wang', a: 1, b: 2, c: 3 }
                        console.log('obj3 is',obj3) obj3 is { a: 1, b: 2, name: 'wang' }
                        浅拷贝时相当于使用 Object.assign() 方法
                        let aClone = { ...a };
                        // 等同
                        let aClone = Object.assign({}, a);
                    </pre>
                </p>
            </div>
            <h4>5.js对象的复制拷贝</h4>
            <div>
                所谓拷贝就是将一个对象的所有属性,复制一份一模一样的到另一个对象里,同时要保证拷贝后的对象和原对象具有相同的原型、实例属性。
                拷贝又分成浅拷贝和深拷贝两种。
                <h5>1.浅拷贝</h5>
                对于嵌套的对象、拷贝的是引用地址。
                <div>
                    1.一种是使用循环语句中的 for in 循环遍历对象的所有可枚举属性。这个方法的问题在于、如果遇到存取器定义的属性、会只拷贝值。
                    <pre>
                        const a = {
                            name:'zhangsan',
                            age:23,
                            hobbies:{
                                hobbyName:'打篮球',
                                move:'走动'
                            }
                        }
                        
                        function extend(to,from) {
                            for (let i in to) {
                                from[i] = to[i]
                            }
                            return from 
                        }
                        
                        const otherObj = extend(a,{})
                        otherObj.hobbies.hobbyName = '修改'
                        console.log('a',a.hobbies.hobbyName) // 修改
                    </pre>
                    2. 增强 for in 循环遍历对象属性、Object.hasOwnProperty()方法去除继承的属性、Object.defineProperty()方法拷贝属性、Object.getOwnPropertyDescriptor()方法获取属性的属性描述对象。
                    <pre>
                        var extend = function (to, from) {
                            for (var property in from) {
                              if (!from.hasOwnProperty(property)) continue;
                              Object.defineProperty(
                                to,
                                property,
                                Object.getOwnPropertyDescriptor(from, property)
                              );
                            }
                          
                            return to;
                          }
                        
                    </pre>
                    3. 扩展运算符 ... 也可以将一个对象的所有属性复制一份到另一个对象
                    <pre>
                        const obj = {
                            name: 'zhangsan',
                            age: 28,
                            gender: 'male',
                            hobbies: {
                                name: '足球'
                            },
                        }
                        const target = {...obj}
                        console.log('target', target)
                        // target{ age: 28, gender: male, hobbies:{name:'修改后的名字'}, name: zhangsan}
                        target.hobbies.name = '修改后的名字'
                        console.log('obj', obj)
                        // obj{ age: 28, gender: male, hobbies:{name:'修改后的名字'}, name: zhangsan}
                    </pre>
                    4. es6 新增Object.assign()方法、它是用于合并对象,当目标对象是空对象是就是浅拷贝。
                    <pre>
                        const obj = {
                            name: 'zhangsan',
                            age: 28,
                            gender: 'male',
                            hobbies: {
                            name: '足球'
                        },
                        }
                        const target = {}
                        Object.assign(target,obj)
                        console.log('target', target)
                        // target{ age: 28, gender: male, hobbies:{name:'修改后的名字'}, name: zhangsan}
                        target.hobbies.name = '修改后的名字'
                        console.log('obj', obj)
                        // obj{ age: 28, gender: male, hobbies:{name:'修改后的名字'}, name: zhangsan}
                    </pre>
                </div>
                <h5>2.深拷贝</h5>
                深拷贝是指创建一个全新的对象、并且递归地复制所有嵌套对象的值、这样原对象和拷贝对象完全独立、互不影响。
                <div>
                    1. JSON.parse(JSON.stringify(obj))、将一个对象利用JSON.stringify将对象转成JSON字符串、再用JSON.parse把字符串解析成对象、一去一来、新的对象产生了、而且对象会开辟新的栈从而实现深拷贝。<br>
                    缺陷: 无法处理 undefined、function、Symbol 等特殊类型、这些类型在转换过程中会丢失。无法处理正则、对象循环引用:即对象中存在循环引用关系时会导致堆栈溢出或报错。
                    <pre>
                        const obj = {
                            name: 'zhangsan',
                            age: 28,
                            gender: 'male',
                            hobbies: {
                                name: '足球'
                            },
                        }
                        const target = JSON.parse(JSON.stringify(obj))
                        console.log('target', target)
                        // target{ age: 28, gender: male, hobbies:{name:'修改后的名字'}, name: zhangsan}
                        target.hobbies.name = '修改后的名字'
                        console.log('obj', obj)
                        // obj{ age: 28, gender: male, hobbies:{name:'足球'}, name: zhangsan}
                    </pre>
                    2. 递归-手撸: 本质就是基础数据类型直接返回、引用类型递归调用方法、然后特殊的引用类型(数组、日期等)要单独判断。
                    <pre>
                        const obj = {
                            name: 'zhangsan',
                            age: 28,
                            gender: 'male',
                            hobbies: {
                                name: '足球'
                            },
                        }
                        function deepClone(origin, hash = new WeakMap()) {
                            if (origin === null) return origin; // 如果是null或者undefined我就不进行拷贝操作
                            if (origin instanceof Date) return new Date(origin); // 日期类型重新生成
                            if (origin instanceof RegExp) return new RegExp(origin); // 正则重新生成
                            // 可能是对象或者普通的值  如果是函数的话是不需要深拷贝
                            if (typeof origin !== "object") return origin;
                            // 是对象的话就要进行深拷贝,并检查是否循环引用
                            if (hash.get(origin)) return hash.get(origin);
                            let target = new origin.constructor();
                            // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身
                            hash.set(origin, target);
                            for (let key in origin) {
                                if (origin.hasOwnProperty(key)) {// 去除继承属性
                                    // 实现一个递归拷贝
                                    target[key] = deepClone(origin[key], hash);
                                }
                            }
                            return target;
                        }
                        const sf = deepClone(obj)
                        sf.hobbies.name = 'sf'
                        sf.name = 'lisisi'
                        sf.age = 10
                        sf.gender = 'female'
                        console.log('sf', sf)// obj{ age: 10, gender: female, hobbies:{name:'sf'}, name: lisisi}
                        console.log('obj', obj)// obj{ age: 28, gender: male, hobbies:{name:'足球'}, name: zhangsan}
                    </pre>
                    3. 第三方库如: lodash的_.cloneDeep方法
                </div>
            </div>
        </div>
        <h3>2、js对象的创建方法</h3>
        <div>
            <h4>1.使用内置的构造函数 Object() 创建</h4>
            <div>
                创建一个对象,使用new运算符调用Object()构造函数,然后再给它添加属性和方法。构造函数就是专门用来创建对象的函数它的首字母默认要大写。
                <pre>
                    语法:var obj = new Object();这样就创建了一个obj对象了。
                    obj.name = 'zhangsan';
                    obj.age = 29;
                    obj.sayName = function(){console.log(this.name)}
                </pre>
            </div>
            <h4>2.使用对象字面量的方法创建</h4>
            <div>
                对象字面量就是在 {} 花括号中直接指定对象含有的属性和属性值。实际开发中多使用对象字面量的声明方式。
                <pre>
                    语法:var obj = {属性名1:属性值1,属性名2:属性值2};
                    注意:属性名和属性值之间使用 : 冒号分隔,名值对之间使用 , 逗号分隔。
                    var obj = {
                        name:'zhangsan',
                        age:29,
                        sayName:function(){console.log(this.name)}
                    }
                    实际上 var obj = {} 是 var obj = new Object();的语法糖。
                </pre>
            </div>
            <h4>3.使用工厂函数的方法创建</h4>
            <div>
                当我们要重复定义很多对象且它们的属性名基本相同时,这时再使用Object()构造函数或者对象字面量方法定义时都会重复编写很多代码。
                就可以使用这个方法。
                这个方法的本质是定义了一个函数,这个函数的返回值是一个对象的实例。
                通过定义形参作为创建的对象的属性,这样传入不同的实参,对象的属性值也就不同了。
                <pre>
                    语法: 
                        function creatPerson(name,属性名2){
                            let obj = new Object()
                            obj.name = name
                            return obj
                        }
                    var obj1 =  creatPerson("zhangsan"); 这时执行一次函数就会生成一个对象。
                    var obj2 =  creatPerson("lisi"); 这时执行一次函数就会又生成一个对象。
                    注意:使用工厂函数方法可以解决创建多个类似对象的问题,但是创建的对象都是使用Object()构造函数创建的,所以都是object类型的,无法具体区分对象的类型。
                </pre>

            </div>
            <h4>4.使用自定义构造函数的方法创建</h4>
            <div>
                构造函数,就是专门来创建对象的函数,与普通函数没什么区别,只是构造函数首字母要大写,
                同时普通函数是直接调用,而构造函数要使用 new 关键字来调用。
                这样使用同一个构造函数创建的对象称为一类对象,所以也将一个构造函数称为一个类,而由它创建出来的对象称为这个类的一个实例。
                <pre>
                    function Person(name,){
                        this.name = name
                    }
                    可以使用 instanceof 运算符 检查一个实例对象是否是某个类的实例。
                        语法:实例对象 instanceof 构造函数(类);如果是则返回true反之则返回false。
                    function Foo(name,age){
                        this.name = name
                        this.age = age
                        return this //默认有返回,不写时new返回的也是这个this对象
                    }
                    var foo = new Foo('zhangsan',25)
                    console.log(foo instanceof Foo)//true
                </pre>
                new 运算符 生成的实例对象能访问构造函数里的属性,也能访问构造函数原型prototype里的属性。
                也就是这个对象的this是指向构造函数里的this。
                构造函数默认是return返回this对象,人为设置返回原始类型的值毫无意义,人为返回是一个对象时new出来的就是返回的对象。
                这时候和普通函数返回一个对象没区别,new运算符也就失去了它的作用而变的毫无意义。所以定义构造函数时一般不要返回值。
                在实例化时,如果不传入参数,构造函数后面的括号()也可以不加,但是建议都加。<br>
                <pre>
                    面试题:描述new一个对象的过程?手动实现一个new操作符?
                    1.立刻在内存中创建一个新的空对象{}作为将要返回的对象实例,
                    2.将这个空对象的原型特性指向构造函数的显示原型prototype上,即: {}.prototype = 构造函数.prototype。
                    3.将新建的空对象{}赋值给构造函数内部中的this,即this指向这个新的空对象。
                    所以this指每次新生成的那个空对象,即每次new出来的那一个,所以针对this的操作都会发生到new出来的那个空对象上。
                    4.逐行执行构造函数中的代码,给新对象添加属性。
                    5.执行完后,如果构造函数返回非空对象,则直接返回该非空对象。否则将新建的空对象作为返回值返回即返回this。
                注意:构造函数每执行一次,就会创建一个新的实例,这时如果一个构造函数中的某个方法是通用的,
                它会被重复创建多次,这样非常浪费内存。因为在js里函数也是一个对象。
                解决方法:
                    1.打这个方法放到全局作用域中定义,但是这样也会造成全局作用域命名空间污染而且也不安全。
                    2.定义到对象的原型属性prototype上。

                与工厂模式的区别
                    1.构造函数方法没有显示的创建对象new Object(),但是后台会自动var  obj = new Object();
                    2.直接将属性和方法赋值给this对象即this就相当与obj
                    3.没用return语句返回对象引用,由后台自动返回。
                </pre>
            </div>
            <h4>5.构造函数和原型模式</h4>
            <div>
                针对4中提到的方法被重复定义的问题,就可以将公共的属性定义到构造函数的原型属性prototype上。
                这是因为js所有的函数都有一个 prototype属性,可以叫显示原型属性,它是浏览器帮忙添加的。它指向一个对象即它的值是一个对象。
                <pre>
                    在它上面定义的属性和方法会被所有对象实例共享:
                    function Person(){}
                    Person.prototype.name = "zhangsan";
                    Person.prototype.sayName = function (){
                        console.log(this.name)
                    };
                    let person1 = new Person()
                    let person2 = new Person()
                    person1.sayName()//zhangsan
                    person2.sayName()//zhangsan
                    console.log(person1.sayName() == person2.sayName())//true
                </pre>

                <h5>1.理解原型</h5>
                <p>
                    js原型就是一个对象,分为隐式原型和显示原型。
                    所有的引用数据类型都有一个隐式原型属性 __proto__ (null除外),它是浏览器帮忙添加,它指向一个对象。
                    所有的函数都有一个显示原型属性 prototype,它也是浏览器帮忙添加,它也指向一个对象。
                    也就是说定义一个对象或者函数它们会自动添加这个原型属性。
                    所有原型对象都会自动获得一个名为constructor属性,它的值是与之关联的那个构造函数。
                </p>
                <h5>2.js对象原型规则</h5>
                <p>
                    <pre>
                        1. js中所有的引用数据类型(对象,数组,函数等)都具有对象的特性,即可自由扩展属性(null除外)
                        例子:
                            var obj = {}
                            obj.name = 'zhangsan'//自由扩展属性
                            var arr = []
                            arr.a = 100
                            function fn(){}
                            fn.age = 20
                        2.所有的引用数据类型都有一个隐式原型属性 __proto__ (null除外),它是浏览器帮忙添加,它指向一个对象。
                        这是浏览器给的实际脚本是没有访问这个特性的标准方法,而是通过[[Prototype]]来表示这个特性。
                        即: 
                            obj.__proto__ = {},
                            arr.__proto__ = {}
                            fn.__proto__ = {}
                        3.所有的函数都有一个显示原型属性 prototype,它也是浏览器帮忙添加,它也指向一个对象。
                        即: 只要创建一个函数,js原型规则就会给这个函数添加一个prototype属性。
                            fn.prototype = {}
                        
                        4.所有的引用数据类型的隐式原型属性__proto__指向它对应的构造函数的显示原型属性 prototype上。
                        即:__proto__与 prototype指向的是同一个对象上,	obj.__proto__ === Object.prototype = {}。
                        这个对象就是原型对象。
                        5.当试图得到引用数据类型的某个属性时,会先在自己本身查找有没有这个属性,如果没有就会去它的__proto__上寻找也就是它的构造函数的prototype上寻找。
                        如果还是没有继续去构造函数的__proto__对象上找,一层一层往上找直到Object.prototype,还是没有就是undefined,这也就形成了原型链。
                    </pre>

                    实例通过隐式原型属性__proto__链接到原型对象,构造函数通过显示原型prototype链接原型对象。
                    注意:原型链只有在检索一个属性值的时候才被用到,同时原型链也是动态更新的在上面添加一个属性会对所有基于该原型链的对象可见。
                </p>
                <h5>3.js原型链</h5>
                <p>
                    根据原型的规则可以在访问一个对象属性时,会按照这个属性的名称先在实例自己本身搜索,找到了就返回找不到就会沿着指针进入原型对象搜索。
                    一层一层往上找直到Object.prototype,还是没有就是undefined,这也就形成了原型链。
                    原型链只有在检索一个属性值的时候才被用到,同时原型链也是动态更新的在上面添加一个属性会对所有基于该原型链的对象可见。
                    同时给实例添加属性会遮蔽原型上同名的属性,即在查找实例本身时找到了就返回值并停止继续向原型对象查找了。

                    原型模式之所以重要是因为js语言提供的原生引用类型的构造函数都在原型上定义了各种实例方法。这样实例对象都可以直接使用原型上的方法。
                </p>

            </div>
            <h4>6.es6使用类关键字声明</h4>
            <div>
                JavaScript 语言中,生成实例对象的传统方法是通过构造函数。ES6 提供了更接近传统语言的写法,引入了 Class(类)这个概念,作为对象的模板。
                通过class关键字,就可以定义类,新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。<br>
                本质上是构造函数生成对象的语法糖,也是使用了原型对象。
                <pre>
                    语法1:类声明,不存在提升。
                    class Person{
                        constructor()
                            //构造函数方法

                        }
                        get value(){} //获取函数
                        set value(newValue){} //设置函数
                        static changeA(){} //静态类方法
                        sayName(){
                            //实例方法
                        }
                    }
                    typeof Person // "function" 类的数据类型就是函数
                    Person === Person.prototype.constructor // true 类本身就指向构造函数
                所以说类是构造函数的另一种写法,也就是语法糖。
                语法2:类表达式
                    const Person = class {

                    }
                </pre>
                
                类包含构造函数方法、实例方法、获取/设置函数、静态类方法但都不是必需的。可以定义空的类。
                类的名字首字母也要大写,以便区别通过它创建的实例。
                方法与方法之间不需要逗号分隔,加了会报错而且所有方法都是不可枚举的。
                并且在类里面定义的所有方法都是定义在类的原型属性 prototype上面,因此在类的实例上面调用方法,其实就是调用原型上的方法。
                使用时和构造函数一样要用new 声明即可,let 实例 = new 类名()
                <pre>
                    // es6生成实例对象
                    // 定义一个私有变量
                        let _age = 25
                        class MathHandle{
                            constructor(x,y){
                                this.x = x
                                this.y = y
                                this.show = () => {console.log('我是类的实例方法',this)}
                            }
                            get age(){
                                return _age //对某个属性设置存值函数和取值函数,拦截该属性的存取行为。
                            }
                            set age(value){
                                if(value < 30 && value > 25){
                                    _age = value
                                }
                            }
                            static show(){
                                console.log('我是类的静态方法',this)
                            }
                            add(){
                                MathHandle.show()
                                return this.x + this.y
                            }
                            show(){
                                console.log('我是类的原型方法',this)
                            }
                        }
                        // 创建实例对象
                        const m = new MathHandle(3,2)
                        console.log(m.add())//5
                        console.log(m.age)//25// 'getter'
                        m.age = 28// setter: 28
                        console.log(m.age)//28
                        console.log(m)//Object { x: 3, y: 2 }
                        console.log(MathHandle)//class MathHandle { constructor(x, y) }
                        console.log(typeof MathHandle)//function
                        console.log(MathHandle.name)//MathHandle
                        console.log(MathHandle === MathHandle.prototype.constructor)//true
                </pre>
                <img src="../../assets/images/class.png" alt=""> <br>
                <h5>1.类构造函数</h5>
                <p>
                    constructor 关键字用于在类定义块内部创建类的构造函数,而方法名constructor则是告诉浏览器在new 操作符创建类的新实例时要调用一次这个函数。
                    也就是说使用new和类就意味着constructor函数会自动被调用。类实例化时传入的参数也是在这里声明定义的。
                    这个是必须的没有时浏览器自动添加一个空的constructor() {}。它执行之后默认返回实例对象即 this,每次实例化this都是实例化的那个对象。
                    constructor(name,age){
                        //这里所有添加到this的属性和方法都是实例上的,每次初始化都会生成一次。
                        this.name = name;
                        this.age = age;
                        this.sayName = () => {console.log('实例属性')}
                        //继承时
                        super();

                    }
                    在继承时必须在这里面执行 super()
                </p>
                <h5>2.静态类方法</h5>
                <p>
                    在类块中使用 static 方法名(){}定义的就是静态类方法,它不会被实例继承,而是直接通过类来调用 类名.静态方法名()。
                    在静态成员中this引用类本身,非常适合作为实例对象的工厂函数生成实例对象。

                </p>
            </div>
        </div>
        <h3>3、js对象属性的描述对象</h3>
		<div>
			JavaScript 提供了一个内部数据结构,用来描述对象属性的特性以及控制它的行为,比如该属性是否可写、可修改、可删除、可遍历等等。
			这个内部数据结构就称为“属性描述对象”(attributes object)。js对象的每个属性都有自己对应的属性描述对象,用来保存该属性的一些元信息。
            分为两类:数据属性和访问器属性。
            <h4>1.数据属性</h4>
            <div>
                它包含一个保存属性值的位置value。具体如下:
                <pre>
                    {
                        value: 123,该属性的属性值,默认为undefined。
                        writable: 是一个布尔值,表示属性值(value)是否可改变,默认直接定义在对象的属性都是true可改变。
                        enumerable: 是一个布尔值,表示该属性是否可枚举/遍历,默认直接定义在对象的属性都是true可枚举。
                        configurable: 是一个布尔值,表示属性的可配置性是否能被delete删除并重新定义,默认直接定义在对象的属性都是true可删除配置。configurable为false时、writable、enumerable和configurable都不能被修改了。
                       }
                </pre>
            </div>
            <h4>2.访问器属性</h4>
            <div>
                它不能和value、writable这两个特性一起出现,主要是使用获取(getter)和设置(setter)函数。
                <pre>
                    {
                        enumerable: false,是一个布尔值,表示该属性是否可枚举/遍历,默认false不可枚举。
                        configurable: false,是一个布尔值,表示属性的可配置性,默认false不可删除配置。
                        get: undefined,是一个函数,表示该属性的取值函数(getter),默认为undefined。
                        set: undefined,是一个函数,表示该属性的存值函数(setter),默认为undefined
                       }
                </pre>
            </div>
            可以通过Object.defineProperty()方法给对象新增或修改属性并设置属性描述对象,它返回修改后的对象。接收三个参数:要添加属性的对象,添加的属性名称,属性描述对象。
            <pre>
                语法: Object.defineProperty(object, propertyName, attributesObject)
                let obj = {}
                Object.defineProperty(obj,name,{
                    writable:false,
                    value:'zhangsan'
                })
                给obj对象添加了一个只读name属性值为'zhangsan'。
            </pre>
            可以通过Object.defineProperties(),复数形式通过多个描述符一次定义多个属性,接收两个参数:要添加属性的对象,另一个属性描述对象。
            <pre>
                Object.defineProperties(obj,{
                    name:{
                        value:'zhangsan'
                    },
                    age:{
                        writable:false
                    }
                })
            </pre>
            注意:默认情况下所有直接定义在对象上的属性的writable、enumerable、configurable值都是true 即可写可读可删除可配置。
            而使用Object.defineProperty()和Object.defineProperties()方法添加的默认writable、enumerable、configurable值为false。
		</div>
        <h3>4、js对象常见的静态方法</h3>
        <div>
            所谓静态方法就是指部署在Object对象自身的方法,比较常见常用的如下:
            <pre>
            原型链相关方法
                Object.create() 该方法接受一个对象作为参数必传、然后一它为原型对象,返回一个新的实例对象。实质相当于是新建一个空的构造函数F、然后让F.prototype属性指向传入的参数对象obj、最后返回一个F的实例、从而实现让该实例继承obj的属性。所以生成的对象会继承它的原型对象的构造函数。
                Object.getPrototypeOf() 获取参数对象的原型对象 prototype、这是获取原型对象的标准方法。之前的无论是显示原型还是隐式原型其实都是宿主环境提供的、而这个是JavaScript语言标准提供的。
                Object.setPrototypeOf() 为参数对象设置原型、返回该参数对象。它接受两个参数、第一个是现有对象、第二个是原型对象。
            对象属性模型的相关方法
                Object.defineProperty() 通过对象的属性描述对象,给对象定义或修改某个属性、返回修改后的对象。接受三个参数、依次如下。object: 属性所在的对象、propertyName: 字符串表示属性名、attributesObject: 属性描述对象。
                Object.getOwnPropertyDescriptor() 获取目标对象自身某个属性的描述对象(不能用于继承属性)、它的第一个参数是目标对象、第二个参数是一个字符串、对应目标对象的某个属性名。
            对象键值对迭代的相关方法
            
                Object.keys() 传入一个参数对象、返回这个对象自身所有可枚举的属性名(不包括继承的)组成的字符串数组。
                    const obj = {
                        p1: 123,
                        p2: 456
                    };
                    Object.keys(obj) // ["p1", "p2"] 
                    
                Object.getOwnPropertyNames() 和Object.keys()作用和用法基本一致、区别在于它会返回不可枚举的属性名。
                    const  a = ['Hello', 'World'];
                    console.log(Object.keys(a)) // ["0", "1"]
                    console.log(Object.getOwnPropertyNames(a)) // ["0", "1", "length"]、返回了不可枚举属性length

                Object.values() ES2017 引入的跟Object.keys()配套使用方法作为遍历对象的补充手段、供for of 循环使用。
                传入一个参数对象、返回这个对象自身的所有可遍历属性对应的属性值组成的数组。
                    const obj = {
                        p1: 123,
                        p2: 456
                    };
                    Object.values(obj) // [123, 456] 

                Object.entries() ES2017 引入的跟Object.keys()配套使用方法作为遍历对象的补充手段、供for of 循环使用。
                返回一个二维数组、数组成员是由参数对象自身所有可遍历属性的键值对数组。
                    const obj = {
                        p1: 123,
                        p2: 456
                    };
                    Object.entries(obj) // [['p1',123],['p2',456]] 

            其它方法
                Object.assign()es6新增方法用于对象的合并  ,将源对象(source)自身所有的可枚举属性,复制到目标对象(target)同名属性后面覆盖前面。第一个参数是目标对象、后面的参数都是源对象。
                const obj = {
                    name: 'zhangsan',
                    age: 28,
                    gender: 'male'
                  }
                  const target = {
                    tag:'目标对象'
                  }
                  
                  const bb = {
                    title:'测试',
                    hobbies: {
                      name:'足球'
                    }
                  }
                  Object.assign(target,obj,bb)
                  console.log('target', target)
                  // {
                  //   age: 28
                  //   gender: male
                  //   hobbies:
                  //   {
                  //     name: 足球
                  //   }
                  //   name: zhangsan
                  //   tag: 目标对象
                  //   title: 测试
                  // }
            </pre>
        </div>
        <h3>5、js对象常见的实例属性和方法</h3>
        <div>
            定义在 Object.prototype 原型对象上的属性和方法它们称为实例属性和方法。所有Object的实例对象都继承了这些方法。
            Object实例对象的方法,主要有以下六个。<br>
            <pre>
                Object.prototype.toString()  返回当前对象对应的字符串形式,默认情况下返回对象的类型字符串。在js数据类型一章中讲过、它就是用来判断数据类型的。
                为了防止实例对象重写这个方法我们都是直接使用对象冒充 call()方法直接调用 Object 对象原型上的toString() 方法的。
                    数值：返回[object Number]。
                    字符串：返回[object String]。
                    布尔值：返回[object Boolean]。
                    undefined: 返回[object Undefined]。
                    null: 返回[object Null]。
                    数组：返回[object Array]。
                    arguments 对象：返回[object Arguments]。
                    函数：返回[object Function]。
                    Error 对象：返回[object Error]。
                    Date 对象：返回[object Date]。
                    RegExp 对象：返回[object RegExp]。
                    其他对象：返回[object Object]。
                
                Object.prototype.hasOwnProperty()  判断某个属性是否为当前对象自身的属性,还是继承自原型对象的属性。接受一个字符串作为参数、返回一个布尔值、表示该实例对象自身是否具有该属性: true-自身的、false-继承的。
                    var obj = {
                        p: 123
                    };
                    obj.hasOwnProperty('p') // true
                    obj.hasOwnProperty('toString') // false

                Object.prototype.isPrototypeOf()  判断当前对象是否为另一个对象的原型。
                    var o1 = {};
                    var o2 = Object.create(o1);
                    var o3 = Object.create(o2);
                    
                    o2.isPrototypeOf(o3) // true
                    o1.isPrototypeOf(o3) // true
            属性:
                construtor 指向用于创建当前对象的构造函数,即Object()构造函数。
            </pre>
        </div>
        <h3>6、js面向对象编程</h3>
        <div>
            <h4>1.面向对象概述</h4>
            <div>
                面向对象编程(Object Oriented Programming,缩写为 OOP)是目前主流的编程范式。
                它将真实世界的各种东西: 一本书、一辆车、一个人、一个塑料袋等等, 以及这些东西之间各种复杂的关系,抽象为一个个对象,然后由对象之间的分工与合作,完成对真实世界实物的模拟。
                而在JavaScript中我们知道、对象就是一个由无序的键值对组成的集合、它就是一个容器。
                比如包一条狗抽象成一个对象 - 狗对象: 它多大、多重、多高等状态信息就抽象为对象的属性, 它会奔跑、休息、吃饭等行为就抽象为对象的方法。<br><br>

                面向对象编程第一步就是要生成一个对象、这个在对象的创建方法一节中已经详细列出。
                在es6之前JavaScript是基于基于构造函数(constructor)和原型链(prototype)来实现、在es6之后引入了 类 class关键字实现。<br>

                面向对象的3大基本特征是: 封装、继承、多态。也是我们学习的主要方向。
                    其中封装就是将客观事物抽象成编程语言中的类,
                    而继承是面向对象编程中讨论最多的话题,一般有接口继承和实现继承两种方式,ECMAScript中只支持实现继承,而且是通过上面说的原型链实现的。
                    多态就是指一个类实例的相同方法在不同情形下有不同的表现形式、也就是子类可以重写实例方法。
            </div>
            <h4>2.ES6之前js面向对象编程的方法</h4>
            <div>
                <h5>1. this 对象 </h5>
                <div>
                    在使用new 构造函数时、生成的定义在构造函数内容的对象 this、它也可以用在别的场合。但是它总是返回一个对象即指向一个对象。
                    实质是js变量作用域的问题: 因为js函数内部是可以引用当前环境的其它变量的、而为了保证在函数体内部获取当前的运行环境(context)准确就需要一种机制。
                    而this 设计的目的就是用来指代函数当前的运行环境。在js变量作用域一节我们知道在JavaScript中有全局作用域、函数作用域、以及块级作用域。
                    <h6>1. 使用场合</h6>
                    <pre>
                        全局环境浏览器 this 指的是顶层对象 window
                        全局node环境 this 指的是global 对象
                        构造函数 this 指的是 每次new时初始化时的实例对象
                        对象的方法 this 指的是方法运行时所在的对象
                    </pre>
                    <h6>2. 对象冒充</h6>
                    JavaScript 提供了call、apply、bind这三个方法、来切换或者固定this的指向。它们都是Function.prototype上的方法即函数实例方法。
                    <pre>
                        Function.prototype.call() 、传入一个对象(如果参数为空、null、undefined则默认为window对象)、指定前面调用函数内部的this指向出入的参数对象。
                        也就是相当于调用函数是在传入对象中执行的,第二个参数是: 逗号分隔的函数调用时需要的实参列表。
                        它的一个应用就是用来调用对象的原生方法、防止被重写。比如之前用来判断数据类型的 toString()方法
                          const zhangsan = {
                            name: 'zhangsan',
                            age: 28,
                            gender: 'male',
                            hobbies: {
                              name: '足球'
                            },
                          }
                          const lisi = {
                            name: 'zhangsan',
                            age: 22,
                            gender: 'male',
                            hobbies: {
                              name: '篮球'
                            },
                          }
                          const age = 12
                          function callThis(base) {
                            console.log(this.age + base)
                          }
                          callThis.call(window,12) // 24
                          callThis.call(zhangsan,12) // 40
                          callThis.call(lisi,12) // 34
                          防止被覆盖
                            var obj = {};
                            obj.hasOwnProperty('toString') // false

                            // 覆盖掉继承的 hasOwnProperty 方法
                            obj.hasOwnProperty = function () {
                            return true;
                            };
                            obj.hasOwnProperty('toString') // true

                            Object.prototype.hasOwnProperty.call(obj, 'toString') // false

                    </pre>
                    <pre>
                        Function.prototype.apply() 和call方法类似、区别在于第二个参数是接收一个数组作为函数执行时需要传入的实参。
                        const zhangsan = {
                            name: 'zhangsan',
                            age: 28,
                            gender: 'male',
                            hobbies: {
                              name: '足球'
                            },
                          }
                          const lisi = {
                            name: 'zhangsan',
                            age: 22,
                            gender: 'male',
                            hobbies: {
                              name: '篮球'
                            },
                          }
                          const age = 12
                          function applyThis(base1,base2) {
                            console.log(this.age + base1+ base2)
                          }
                          
                          applyThis.apply(window,[6,2]) // 20
                          applyThis.apply(zhangsan, [6, 2]) // 36
                          applyThis.apply(lisi, [6, 2]) // 30
                          应用1: 可以快速找出一个纯数数组的最大元素
                          var a = [10, 2, 4, 15, 9];
                          Math.max.apply(null, a) // 15
                          应用2: 将类数组对象转为真正的数组、es6之前非常常用
                          Array.prototype.slice.apply({0: 1, length: 1}) // [1]
                    </pre>
                    <pre>
                        Function.prototype.bind() 不会立即执行而是将函数体内的this绑定到某个对象、然后每次执行都会返回一个新的函数。
                    </pre>
                </div>
                <h5>2.js实现继承的方法</h5>
                面向对象编程很重要的一个方面就是继承、我们知道JavaScript是只支持实现继承的、通过构造函数和原型链来实现、下面介绍常见的继承方法。
                <div>   
                    <h6>1.原型链继承</h6>
                    <p>
                        也就是子类原型对象等于一个父类实例、子类.prototype = new 父类(),这种改变原型对象的指向之后 子类.prototype 上的constructor属性也被修改成了 父类()。
                        而且,子类要重写父类的方法或者新增方法都要在原型赋值之后再添加到子类的原型上。
                        另一个问题是如果父类原型中包含了引用类型的值时,那么父类的所有实例对象都会共享,而实例对象又被赋值给了另一个子类的原型对象,这就导致实例属性变成了原型属性。
                        也就是每个实例对引用类型的修改都会影响其它的子类实例。
                        第二个问题是子类型在实例化时是不能给父类型的构造函数传参的。 
                        <pre>
                            // Box()构造, 被继承的函数叫做超类型（父类, 基类）
                                function Box() {
                                this.name = '张三';
                                }
                                Box.prototype.sayName = function () {
                                console.log(`我是父类原型上定义的方法${this.name}`)
                                }
                                //Desk()构造,继承的函数叫做子类型（子类,派生类）
                                function Desk() {
                                this.age = 23;
                                }
                                // 实现继承 Box
                                Desk.prototype = new Box();
                                // 必须在原型赋值之后才能添加或重写实例方法
                                Desk.prototype.deskTalk = function () {
                                console.log('hello desk')
                                }
                                let desk = new Desk();
                                console.log('desk.age is', desk.age); // 自身属性 - desk.age is 23
                                console.log('desk.name is', desk.name);//继承来的属性 - desk.name is 张三
                                desk.sayName();//继承来的方法 - 我是父类原型上定义的方法张三
                                function Table() {//Table()构造
                                this.level = 'aaaaaa';
                                }
                                Table.prototype = new Desk();
                                let table = new Table();
                                console.log('table.level is', table.level);//自身属性 - table.level is aaaaaa
                                console.log('table.age is', table.age);//继承了Desk的age - table.age is 23
                                console.log('table.name is', table.name);//继承了Box的name - table.name is 张三
                                table.sayName();//继承来的方法
                        </pre>
    
                    </p>
                    <h6>2.对象冒充继承</h6>
                    <p>
                        为了解决原型包含引用值导致的继承问题以及不能向父类构造函数传参的问题,就可以使用对象冒充继承方法(也叫对象伪装/经典继承)。
                        基本思路是:在子类构造函数内调用父类构造函数,通过call()或apply()方法以新创建的对象作为上下文执行构造函数并传入参数。
                        相当于子类对象上运行了父类构造函数中的所有初始化代码,就会让子类实例具有父类实例的属性,这时父类原型上同名的属性会被遮蔽。
                        但是冒充构造函数继承也有问题:只能访问定义在构造函数中定义的方法因此函数不能重用,也就是子类不能访问父类原型上定义的方法。
                        <pre>
                            function Box(name, age) {
                                this.name = name;
                                this.age = age;
                                this.family = ['哥哥', '姐姐', '弟弟',];
                                this.sayHi = function () {
                                  console.log(`hi${this.name}`)
                                }
                              }
                              Box.prototype.family = '家庭';
                              Box.prototype.sayName = function () {
                                console.log(`hello${this.name}`)
                              };
                              
                              function Desk(name, age) {
                                //对象冒充继承且可以给父类构造函数传参
                                Box.call(this, name, age);
                              }
                              let desk1 = new Desk('wang', 23);
                              desk1.family.push("妹妹");
                              console.log(desk1.family)//[ "哥哥", "姐姐", "弟弟", "妹妹" ]
                              console.log(desk1.name)//'wang'
                              desk1.sayHi()//只能访问构造函数内的方法 - hiwang
                              desk1.sayName()//desk1.sayName is not a function
                              console.log(desk1.age)//23
                              let desk2 = new Desk('qiao', 22);
                              console.log(desk2.family)// [ "哥哥", "姐姐", "弟弟" ]
                              console.log(desk2.name)//'qiao'
                              console.log(desk2.age)//22
                              desk2.sayHi()//只能访问构造函数内的方法
                              desk2.sayName()//desk2.sayName is not a function报错
                        </pre>
                    </p>
                    <h6>3.组合继承</h6>
                    <p>
                        有时候也叫伪经典继承,它是综合了原型链继承和对象冒充继承将两者的优点集中起来的一种继承方法。
                        基本思路是:使用原型链继承父类原型上的属性和方法,使用对象冒充继承父类构造函数内的属性(即实例属性)和传参。
                        它解决了原型链继承和对象冒充继承的不足,是JavaScript中使用最多的继承方式。而且也保留了instanceof操作符和isPrototypeOf()方法识别合成对象的能力。
                        组合继承也存在效率问题:父类构造函数始终会被调用两次,第一次是父类实例赋值给子类原型时,第二次是子类构造函数内冒充父类时。
                        <pre>
                            function Box(age){
                                this.name=['wang','pan','Hello']
                                this.age=age;
                            }
                            Box.prototype.run = function(){
                                return this.name  +  this.age +  '运行中....';
                            };
                        
                            function Desk(age){
                                //对象冒充,继承实例属性
                                Box.call(this,age);
                            }
                            //原型链继承,继承原型方法
                            Desk.prototype = new Box();
                            // 修正构造器属性指向
                            Desk.prototype.constructor = Desk
                            Desk.prototype.sayAge = function(){
                                return this.age
                            };
                            let desk1 = new Desk(23);
                            desk1.name.push('zhangsan')
                            console.log(desk1.name)//[ "wang", "pan", "Hello", "zhangsan" ]
                            console.log(desk1.run());//wang,pan,Hello23运行中....
                            console.log(desk1.sayAge());//23
                        
                            let desk2 = new Desk(27);
                            console.log(desk2.name)// [ "wang", "pan", "Hello" ]
                            console.log(desk2.run());//wang,pan,Hello27运行中....
                            console.log(desk2.sayAge());//27
                        
                            console.log(desk1 instanceof Desk)//true
                            console.log(desk1 instanceof Box)//true
                            console.log(desk1 instanceof Object)//true
                        
                            console.log(Object.prototype.isPrototypeOf(Box))
                            console.log(Box.prototype.isPrototypeOf(desk1))
                            console.log(Desk.prototype.isPrototypeOf(desk1))
                        </pre>
                    </p>
                    <h6>4.原型式继承</h6>
                    <p>
                        即使不定义构造函数或者不知道构造函数名时也可以通过原型实现对象之间的信息共享这就是原型式继承:
                        <pre>
                            // 原型式继承
                            function createObject(o){
                                function F(){}
                                F.prototype = o
                                return new F()
                            }
                            const person = {
                                name:"zhangsan",
                                friends:["lisi","wangwu","maliu"]
                            }
                            let objectPerson = createObject(person)
                            console.log(objectPerson.friends)// [ "lisi", "wangwu", "maliu", "rob", "bab" ]
                        </pre>
                        它的本质是通过创建一个临时的构造函数将传入的对象赋值给这个临时构造函数的原型,然后返回这个临时类型的一个原型。
                        本质是对传入对象的一次浅拷贝。如果你有一个对象,想在这个对象的基础上再创建一个新的对象。你就可以使用原型式继承。
                        ECMAScript5中增加了 Object.create() 方法将原型式继承的概念规范化,也就是用来代替这个object这个函数。
                        Object.create(新对象原型的对象,{})接收两个参数,作为新对象原型的对象,给新对象自身定义额外属性的对象和Object.defineProperties()方法第二个参数一样的对象。
                        生成的新对象以给定的参数对象为原型并继承它所有的属性和方法。
                        缺点和原型链继承一样引用类型属性被所有子类实例共享。
                        <pre>
                            Object.create()实际上也可以看作是对object()的再封装,只是把它挂载在了Object上。
                            if (typeof Object.create !== 'function') {
                                Object.create = function (obj) {
                                  function F() {}
                                  F.prototype = obj;
                                  return new F();
                                };
                            }
                        </pre>
                        <pre>
                            const person = {
                                name: "zhangsan",
                                friends: ["lisi", "wangwu", "maliu"]
                              }
                              let anothorPerson1 = Object.create(person, {
                                name: {
                                  value: 'anothor1'
                                }
                              })
                              anothorPerson1.friends.push("rob")
                              let anothorPerson2 = Object.create(person, {
                                name: {
                                  value: 'anothor2'
                                }
                              })
                              anothorPerson2.friends.push("bab")
                              console.log(anothorPerson1.name)// anothor1
                              console.log(anothorPerson2.name)// anothor2
                              console.log(anothorPerson1.friends)// [ "lisi", "wangwu", "maliu", "rob", "bab" ]
                        </pre>
                    </p>
                    <h6>5.寄生式继承</h6>
                    <p>
                        和原型式继承类似,基本思路是另外创建一个实现继承的函数,以某种方式增强对象,然后再返回这个对象。
                        有点类似工厂模式,可以说是对原型式继承的一种封装。
                        function createObj(o){
                            let clone = object(o);//通过调用函数创建一个新对象
                            clone.sayHi = function(){//以某种方式增强这个新对象
                                console.log('hi')
                            }
                            return clone;//返回这个对象
    
                        }
                        es5提供了Object.create(新对象原型的对象,{})方法之后当然是应该使用它来替换object(o)函数。
                        <pre>
                            let person = {
                                name: "zhangsan",
                                friends: ["lisi", "wangwu", "maliu"]
                              }
                              function createAnothor(original) {
                                let clone = Object.create(original);
                                // 增强对象
                                clone.sayHi = function () {
                                  console.log(`hi`)
                                }
                                return clone;
                              }
                              // 寄生式继承
                              let anothor = createAnothor(person);
                              console.log(anothor.name)//zhangsan
                              console.log(anothor.friends)// [ "lisi", "wangwu", "maliu" ]
                              anothor.sayHi()//hi                              
                        </pre>
                        它跟原型式继承一样适合只关注对象,而不在乎类型和构造函数的场景。缺点是类似对象冒充因为是在方法里添加函数难以重用同时每次创建对象都会创建一遍方法。
                    </p>
                    <h6>6.寄生式组合继承</h6>
                    <p>
                        它是通过冒充构造函数继承属性,使用混合式原型链继承方法。
                        <pre>
                            基本思路是不再通过调用父类构造函数赋值给子类原型,而是使用寄生式继承获取父类原型的一个副本来赋值给子类原型。
                            即使用寄生式继承来继承父类原型,然后将返回的新对象赋值给子类原型。
                            关键是寄生式继承函数 inheritPrototype(),接收两个参数,子类构造函数和父类构造函数。
                            函数内部第一步就是使用原型式继承创建父类原型的一个副本并赋值给子类原型。
                            第二步是重新指定子类原型上的constructor属性为子类自己,解决由于重写原型导致默认constructor丢失的问题。
                            第二步是因为Object.create()方法生成的对象,继承了它的原型对象的构造函数,所以要重新指定。
                            function Box(age){
                                this.names=['wang','pan','Hello']
                                this.age=age;
                            }
                            Box.prototype.run = function(){
                                return this.names  +','+  this.age +','+ '父类原型run方法运行中....';
                            };
                        
                            function Desk(age){
                                //对象冒充,继承实例属性、给父类构造传参
                                Box.call(this,age);
                            }
                            //不再使用这个方法
                            // Desk.prototype = new Box();
                            // 使用寄生式继承
                            function inheritPrototype(subType,superType){
                                // 子类原型等于父类原型的一个副本
                                subType.prototype = Object.create(superType.prototype);//创建对象
                                subType.prototype.constructor = subType;//重新指定constructor属性,增强对象
                            }
                            // 继承
                            inheritPrototype(Desk,Box);
                            Desk.prototype.sayAge = function(){
                                return this.age
                            };
                            let desk1 = new Desk(23);
                            desk1.names.push('zhangsan')
                            console.log(desk1.names)//[ "wang", "pan", "Hello", "zhangsan" ]
                            console.log(desk1.run());//wang,pan,Hello,zhangsan,23,父类原型run方法运行中....
                            console.log(desk1.sayAge());//23
                            console.log(desk1 instanceof Desk)//true
                            console.log(desk1 instanceof Box)//true
                            console.log(desk1 instanceof Object)//true
                            let desk2 = new Desk(27);
                            console.log(desk2.names)// [ "wang", "pan", "Hello" ]
                            console.log(desk2.run());//wang,pan,Hello,27,父类原型run方法运行中....
                            console.log(desk2.sayAge());//27

                            最终只调用了一次父类构造函数,而且跟组合式继承一样也保留了instanceof操作符和isPrototypeOf()方法识别合成对象的能力。
                            可以说这个继承方式是引用类型继承的最佳模式了。
                        </pre>
                    </p>
                    <h6>7.ECMAScript6类继承</h6>
                    <p>
                        ECMAScript5中使用了多种方法来模拟类似于类的行为,但是每种方法都有自己的问题和妥协。所以实现继承的代码也显得非常冗长和混乱。
                        而在ECMAScript6在引入类定义之后继承是非常方便的,它是原生支持类继承机制的。
                        <pre>
                            class Point {
                                // 实例化时要传参就需要在构造方法 constructor方法上定义
                                constructor(x, y) {
                                  this.x = x;
                                  this.y = y;
                                }
                                // 这里声明的方法其实是定义在 Point.prototype 上面
                                toString() {
                                  return '(' + this.x + ', ' + this.y + ')';
                                }
                              }
                              // 子类继承父类
                              class ColorPoint extends Point {
                                constructor(x, y, color) {
                                  super(x, y); // 相当于调用父类的constructor(x, y)、同时传参
                                  this.color = color;
                                }
                              
                                toString() {
                                  return this.color + ' ' + super.toString(); // 调用父类的toString()
                                }
                              }
                              const cp = new ColorPoint(2,3,'red')
                              
                              console.log(cp.x) // 继承属性 2
                              console.log(cp.y) // 继承属性 3
                              console.log(cp.color) // 自身的属性 red
                              console.log(cp.toString()) // 自身的方法和调用继承方法 red (2, 3)
                        </pre>
                    </p>
                    <h6>8.多重继承</h6>
                    <p>
                        JavaScript 原生无论是es5还是es6都不提供多重继承功能,即不允许一个对象同时继承多个对象。但是,可以通过变通方法,实现这个功能。
                        es5主要是通过Object.assign()方法实现的、es6则是通过混入(mixin)模式来实现。其实两者都是混入模式
                        <pre>
                            es5
                            function M1() {
                                this.hello = 'hello';
                            }
                            function M2() {
                                this.world = 'world';
                            }
                            function S() {
                                M1.call(this);
                                M2.call(this);
                            }
                            继承 M1
                            S.prototype = Object.create(M1.prototype);
                            // 继承链上加入 M2
                            Object.assign(S.prototype, M2.prototype);
                            // 指定构造函数
                            S.prototype.constructor = S;
                            let s = new S();
                            console.log( s.hello )// 'hello'
                            console.log( s.world )// 'world'
                        </pre>
                        <pre>
                            es6
                            function mix(...mixins) {
                                class Mix {
                                    constructor() {
                                    // 遍历传入的参数列表
                                    for (let mixin of mixins) {
                                        copyProperties(this, new mixin()); // 拷贝实例属性
                                    }
                                    }
                                }
                                
                                for (let mixin of mixins) {
                                    copyProperties(Mix, mixin); // 拷贝静态属性
                                    copyProperties(Mix.prototype, mixin.prototype); // 拷贝原型属性
                                }
                                // 返回整合后的类
                                return Mix;
                            }
                            // 复制属性
                            function copyProperties(target, source) {
                                for (let key of Reflect.ownKeys(source)) {
                                    // 不复制构造方法、原型、name属性
                                    if ( key !== 'constructor' && key !== 'prototype'&& key !== 'name') {
                                        // 获取每个属性的属性描述对象
                                        let desc = Object.getOwnPropertyDescriptor(source, key);
                                        // 给目标对象复制一份
                                        Object.defineProperty(target, key, desc);
                                    }
                                }
                            }
                            // 使用
                            class Loggable {}
                            class Serializable {}
                            class DistributedEdit extends mix(Loggable, Serializable) {
                            // ...
                            }
                        </pre>
                    </p>
                </div>
            </div>
            <h4>3.ES6之后js面向对象编程的方法</h4>
            <div>
                我们知道在es5时JavaScript中生成实例对象的方法是通过构造函数、跟传统的面向对象语言写法差异是比较大的。
                所以在es6 之后引入了 Class(类)的概念、作为对象的模板。通过class 关键字就可以定义类。
                它可以看作是一个语法糖、因为它绝大部分功能es5的构造函数都能做到。它只是比构造函数写法上更像面向对象编程的语法而已。
                <h5>1. classs 基本语法 </h5>
                <div>
                    使用class关键字声明一个类时、和构造函数声明时一样、要传参就需要卸载构造方法: constructor()上。
                    不写构造方法时浏览器会自动帮忙添加一个空的constructor()方法、然后方法的声明使用es对象增强模式不用使用函数声明语句function、
                    方法之间也不用使用逗号分隔、声明的方法都是定义在类的原型对象 prototype属性上且都不可枚举、使用typeof 运算符类的数据类型是函数同时 类原型的constructor属性指向构造函数本身。
                    使用上也是使用new运算符初始化,和构造函数的用法一致。
                    <pre>
                        es5 构造函数
                        function Point(x, y) {
                            this.x = x;
                            this.y = y;
                        }
                        Point.prototype.toString = function () {
                            return '(' + this.x + ', ' + this.y + ')';
                        };
                          
                        var p = new Point(1, 2);

                        ES6 class 类写法
                        class Point {
                            // 实例化时要传参就需要在构造方法 constructor方法上定义
                            constructor(x, y) {
                                this.x = x;
                                this.y = y;
                            }
                            // 这里声明的方法其实是定义在 Point.prototype 上面
                            toString() {
                                return '(' + this.x + ', ' + this.y + ')';
                            }
                        }
                        typeof Point // "function"
                        Point === Point.prototype.constructor // true
                        const p = new Point(1, 2);
                    </pre>
                </div>
                <h5>2. 构造方法 constructor</h5>
                <div>
                    它是类的默认方法通过new运算符生成对象实例时自动调用该方法、一个类必须有这个方法不显性声明时会自动添加一个空的构造方法constructor() {}。
                    它的返回值和构造函数的写法一致即也返回 this 当前实例对象、另一点是如果实例化需要传参也是在这个构造方法中传入。
                </div>
                <h5>3. 类的实例</h5>
                <div>
                    生成类的实例方法和es5使用构造函数生成一样、而且类必须使用new调用不然报错。同时在类中声明在this对象上的属性都是实例属性、否则都是定义在类的原型对象上。
                    和es5一样、所有类的实例对象都共享一个原型对象、所以所有实例的隐式原型属性都相等且都等于构造函数的显示原型属性即: p.__proto__ === p1.__proto__ === Point.prototype // true <br>
                    注意: 不要通过实例的隐式原型对象添加方法
                </div>
                <h5>4.静态方法和属性</h5>
                <div>
                    如果在一个方法前、加上static关键字、就表示该方法不会被实例继承、而是直接通过类来调用、这就称为“静态方法”。
                    注意: 如果静态方法包含this关键字、这个this指的是类、而不是实例。父类的静态方法可以被子类继承从super对象上调用的。
                    <pre>
                        class Foo {
                            static classMethod() {
                              return 'hello';
                            }
                          }
                          
                          Foo.classMethod() // 'hello'
                          
                          var foo = new Foo();
                          foo.classMethod()
                          // TypeError: foo.classMethod is not a function
                    </pre>
                    静态属性指的是 Class 本身的属性、即Class.propName、而不是定义在实例对象(this)上的属性。
                    有提案写法和静态方法一直、在静态属性前加上 static 关键字即可。目前可不必理会。
                </div>
                <h5>5.Class 的继承</h5>
                <div>
                    在es引入类之后对象的继承是非常方便的、Class 通过 extends 关键字就可以实现继承、让子类继承父类所有的属性和方法。
                    在子类的构造方法中要调用super() 方法、这里这个super表示父类的构造函数用来新建一个父类的实例对象。
                    ES6 规定、子类必须在constructor()方法中调用super()、否则就会报错。这是因为子类自己的this对象、必须先通过父类的构造函数完成塑造、得到与父类同样的实例属性和方法、然后再对其进行加工、添加子类自己的实例属性和方法。
                    如果不调用super()方法、子类就得不到自己的this对象也就是调用之后才可以使用this。同时super()方法可以传参给父类(有点类似对象冒充)。<br>
                    原因: ES6 的继承机制和 ES5的完全不一样<br>
                    ES5 是先创建一个独立的子类实例对象、然后将父类的方法添加到这个对象上。即实例生成在前、继承在后。<br>
                    ES6 是先将父类的属性和方法添加到一个空的对象上、然后将这个对象作为子类的实例。即继承在前、实例在后。
                    <pre>
                        class Point {
                            // 实例化时要传参就需要在构造方法 constructor方法上定义
                            constructor(x, y) {
                                this.x = x;
                                this.y = y;
                            }
                            // 这里声明的方法其实是定义在 Point.prototype 上面
                            toString() {
                                return '(' + this.x + ', ' + this.y + ')';
                            }
                        }
                        // 子类继承父类
                        class ColorPoint extends Point {
                          constructor(x, y, color) {
                            super(x, y); // 相当于调用父类的constructor(x, y)
                            this.color = color;
                          }
                        
                          toString() {
                            return this.color + ' ' + super.toString(); // 调用父类的toString()
                          }
                        }
                    </pre>
                    super关键字
                    <pre>
                        当做方法使用时、代表父类的构造函数、只能用在子类的构造函数之中、用在其他地方就会报错。ES6 要求、子类的构造函数必须执行一次super()函数。可以传参给super方法就是给父类传参。
                        当做对象使用时、在普通方法中、指向父类的原型对象: 在静态方法中、指向父类。
                    </pre>
                </div>
            </div>

        </div>
    </div>
<!-- js -->
<script>
window.onload = function (){
/*js对象的创建方式*/
    //1,使用new运算符创建对象并操作属性
    // var obj = new  Object();
    // console.log(typeof obj)//object
    // obj.name='王耿';//向对象中添加属性name
    // obj.age=23;//添加属性age
    // console.log(obj);//{ name: "王耿", age: 23 }
    // console.log(obj.name);//"王耿"
    // console.log(obj.age);//23
    // obj.name="蔵青安";//修改属性
    // console.log(obj.name);//"蔵青安"
    // delete obj.name;//删除属性
    // console.log(obj);//{ age: 23 }
    
    //2,字面量创建的方法
    // var  obj={
    // 	name :'王耿', 
    // 	age:23,
    // 	run:function(){
    // 		return '123';
    // 		//匿名函数
    // 	}
    // };
    // //两种输出方式
    // console.log(obj.name);
    // obj.name="巧巧"
    // obj.gender = "female"
    // console.log(obj);//{ name: "巧巧", age: 23, run: run(), gender: "female" }
    // console.log(obj.name);//巧巧
    // console.log(obj["name"]);//巧巧
    // console.log(obj.run());

    // 3,使用工厂函数的方法创建对象
    // function creatPerson(){
    // 	var obj = new Object();
    // 	//添加属性
    // 	obj.name= "孙悟空";
    // 	obj.age = 24;
    // 	obj.gender = "男";
    // 	obj.sayName = function (){
    // 		console.log(this.name);
    // 	};
    // 	return obj;//返回创建的对象
    // }
    // var obj = creatPerson();//这就是一个用函数创建的对象但是对象的属性值都写死了不好,
    // console.log(obj);//{ name: "孙悟空", age: 24, gender: "男", sayName: sayName() }
    // console.log(obj.name);//"孙悟空"
    // console.log(obj.age);//24

    //改进:定义形参,这样在调用时可以传入不同的实参。
    // function creatPerson(name,age,gender){
    // 	var obj = new Object();
    // 	//添加属性
    // 	obj.name= name;
    // 	obj.age = age ;
    // 	obj.gender = gender ;
    // 	obj.sayName = function (){
    // 		console.log(this.name);
    // 	};
    // 	return obj;//返回创建的对象
    // }
    // var obj = creatPerson("王",24,"男");//调用时传入不同的值
    // console.log(obj);//{ name: "王", age: 24, gender: "男", sayName: sayName() }
    // console.log(obj.name);//"王"
    // console.log(obj.age);//24

    //4,自定义构造函数创建对象
    // function Person(name,age){
    // 	this.name =  name;//这里的this就是每次新创建出来的对象,这样传什么值就建什么name。
    // 	this.age = age;
    // 	this.sayName = function(){
    // 		console.log(this.name);
    // 	};
    // }
    // var per = new Person("王耿",24);
    // console.log(per)//{ name: "王耿", age: 24, sayName: sayName() }
    // console.log(per.name)//"王耿"
    // console.log(per.age)//24
    // per.name = "蔵青安"
    // console.log(per.name)//"蔵青安"
    
    // 5类创建
    // class Person {
    //     constructor(name,age){
    //         this.name = name;
    //         this.age = age
    //     }
    //     sayName(){
    //         console.log(this.name)
    //     }
    // }
    // const person = new Person("王耿",24)
    // console.log(person)//Object { name: "王耿", age: 24 }
    // console.log(person.name)//王耿
    // console.log(person.age)//24
    // person.sayName()//王耿

    //es5生成实例对象
    // function MathHandle(x,y) {
    //     this.x = x
    //     this.y = y
    // }
    //方法写在原型对象上
    // MathHandle.prototype.add = function(){
    //         // 引用静态方法
    //         MathHandle.show()
    //     return this.x + this.y
    // }
    // // 静态方法(实例方法)
    // MathHandle.show = function(){
    //     console.log('我是静态方法')
    // }
    // //创建实例对象
    // var m = new MathHandle(3,2)
    // console.log(m.add())//5
    // console.log(m)//Object { x: 3, y: 2 }
    // console.log(MathHandle)//function MathHandle(x, y)
    // console.log(typeof MathHandle)//function
    // console.log(MathHandle.name)//MathHandle

    // es6生成实例对象
    // 定义一个私有变量
    // let _age = 25
    // class MathHandle{
    //     constructor(x,y){
    //         this.x = x
    //         this.y = y
    //     }
    //     get age(){
    //         return _age
    //     }
    //     set age(value){
    //         if(value < 30 && value > 25){
    //             _age = value
    //         }
    //     }
    //     static show(){
    //         console.log('我是类的静态方法')
    //     }
    //     add(){
    //         MathHandle.show()
    //         return this.x + this.y
    //     }
    // }
    // // 创建实例对象
    // const m = new MathHandle(3,2)
    // console.log(m.add())//5
    // console.log(m.age)//25
    // m.age = 28
    // console.log(m.age)//28
    // console.log(m)//Object { x: 3, y: 2 }
    // console.log(MathHandle)//class MathHandle { constructor(x, y) }
    // console.log(typeof MathHandle)//function
    // console.log(MathHandle.name)//MathHandle
    // console.log(MathHandle === MathHandle.prototype.constructor)//true

/*js对象属性的描述对象*/
    // let person = {};
    // Object.defineProperty(person,"name",{
    //     writable:true,
    //     value:"zhangsan"
    // })
    // console.log(person.name)//zhangsan
    // person.name = "lisi"
    // console.log(person.name)//lisi

    // let book = {
    //     year_:2021,
    //     edition:1
    // };
    // Object.defineProperty(book,"year",{
    //     get:function(){
    //         return this.year_;
    //     },
    //     set:function(newValue){
    //         if(newValue > 2019){
    //             this.year_ = newValue;
    //             this.edition += newValue - 2017
    //         }
    //     }
    // })
    // book.year = 2022;
    // console.log(book.edition)

    // let descriptor = Object.getOwnPropertyDescriptor(book,"year")
    // let descriptors = Object.getOwnPropertyDescriptors(book,)
    // console.log(descriptor)
    // console.log(descriptors)

/*枚举对象的属性*/
    // function Person(){}
    // Person.prototype.name ="zhangsan";
    // Person.prototype.age = 27;
    // Person.prototype.gender = "male";
    // Person.prototype.city = "guangzhou";
    // Person.prototype.sayName = function(){
    //     console.log(this.name)
    // };
    // let person = new Person();
    // person.name = "lisi";
    // person.age = 22;
    // person.gender = "female";
    // // for in
    // let arr = []//定义一个数组接收遍历的对象属性 
    // for(let i in person){
    //     arr.push(i)
       
    // }
    // console.log('arr is',arr)//arr is Array(5) [ "name", "age", "gender", "city", "sayName" ]
    // const result = Object.keys(person)
    // console.log('result is',result)//result is Array(3) [ "name", "age", "gender" ]
    // const otherResult = Object.getOwnPropertyNames(person)
    // console.log('otherResult is',otherResult)//result is Array(3) [ "name", "age", "gender" ]
    // // es8
    // const valusResult = Object.values(person)
    // console.log('valusResult is',valusResult)//valusResult is Array(3) [ "lisi", 22, "female" ]
    // const entriesResult = Object.entries(person)
    // console.log('entriesResult is',entriesResult)//entriesResult is[[ "name", "lisi" ],[ "age", 22 ],[ "gender", "female" ]]

    // 复制对象
    // let target = {product:'电器',price:200}
    // let source = {color:'red',weight:100}
    // Object.assign(target,source)
    // console.log(target)
    // console.log(source)
    // //对象变数组
    //  // 对象和数组之间的转换
    // const obj = {a:1,b:2,c:3,d:"my"}
    // // 转成[{text:1,value:'a'},{text:2,value:'b'},{text:3,value:'c'},{text:4,value:'d},]
    // console.log('对象转成数组方法:',Object.entries(obj))
    // //Object.entries方法转变成: [["a",1],["b",2],["c",3],["d","my"]]
    // const ret = Object.entries(obj).map( v => {
    //     return {text:v[1],value:v[0]}
    // })
    // console.log(ret)
    // //再将ret数组变回obj格式
    // // 使用reduce方法
    // const robj1 = ret.reduce((sum,v) => {
    //     //这里v就是数组里的每一项了即里面的一个对象。
    //     sum[v.value] = v.text
    //     return sum
    // },{})
    // console.log(robj1)

 /*js对象的增强语法*/
    // let username5 = "zangqingan";
    // let age5 = 24;
    // let obj5 ={
    //     username5:username5,
    //     age5:age5,
    //     getName:function(){
    //         return this.username5;
    //     }
    // }
    // console.log(obj5);//Object { username: "zangqingan", age: 24, getName: getName() }
    // console.log(obj5.getName());//zangqingan

    // // es6写法
    // let username6 = "qiaoqiao";
    // let age6 = 22;
    // let obj6 ={
    //     username6,
    //     age6,
    //     getName(){
    //         return this.username6;
    //     }
    // }
    // console.log(obj6);//Object { username6: "qiaoqiao", age6: 22, getName: getName() }
    // console.log(obj6.getName());//qiaoqiao

    // let obj1 = { a: 1, b: 2 };
    // let obj2 = { name:"wang",...obj1, c: 3 }; 
    // let obj3 = { ...obj1,name:"wang"};
    // console.log('obj1 is',obj1)//{ a: 1, b: 2 }
    // console.log('obj2 is',obj2)//{ name: "wang", a: 1, b: 2, c: 3 }
    // console.log('obj3 is',obj3)// { a: 1, b: 2, name: "wang" }


 /*js对象new操作符实现*/
    // function Student(name,age,gender){
    //     this.name = name
    //     this.age = age
    //     this.gender = gender

    // }
    // 使用new运算符初始化一个实例
    // const student1 = new Student('zhangsan',27,'male')
    // console.log('new student is',student1)//new student is Object { name: "zhangsan", age: 27, gender: "male" }
    
    // new手动实现,出入一个构造函数和形参
    // function myNew(Fn, ...args) {
    //     // 1.创建一个空对象
    //     let obj = {}        // let obj = null
    //     // 2.对象的隐式原型指向构造函数的显示原型
    //     obj.__proto__ = Fn.prototype // Object.setPrototypeOf(obj, Fn.prototype)
    //     // 3.绑定obj的this到构造函数的this
    //     let result = Fn.apply(obj, args)
    //     return result instanceof Object ? result : obj
    // }
    // const student2 = myNew(Student,'madongmei',27,'female')
    // console.log('myNewstudent is',student2)
    // myNewstudent is Object { name: "madongmei", age: 27, gender: "female" }

    // 改进
    // function myNew2(Fn, ...args){
    //     // 判断第一个参数传入不是函数报错
    //     if(typeof Fn !== 'function'){
    //         throw 'myNew2 function the first param must be a function';
    //     }
    //     // 创建一个新的对象并且新对象的原型是传入的构造函数原型
    //     // 此时 newObj = {},newObj.__proto__ = Fn.prototype
    //     const newObj = Object.create(Fn.prototype)
    //     // 重新绑定this
    //     const result = Fn.apply(newObj,args)
    //     // 返回创建的对象
    //     return result instanceof Object ? result : newObj

    // }
    // const student3 = myNew2(Student,'马六',32,'male')
    // console.log('myNew2student is',student3)
    // myNew2student is Object { name: "马六", age: 32, gender: "male" }

 /*js对象拷贝*/
    // 浅拷贝
    // function clone(obj){
    //     let newobj = {}
    //     for(let i in obj){
    //         newobj[i] = obj[i]
    //     }
    //     return newobj
    // }
    // const goods = {
    //     name:'普通酒',
    //     category:'酒水',
    //     weight:'100kg',
    //     items:{
    //         childName:'葡萄酒',
    //         price:20,
    //         children:{
    //             age:40,
    //             city:'hangzhou'
    //         },
    //         ary:['甘肃','宁夏','陕西']
            
    //     }
    // }
    // const result = clone(goods)
    // console.log('result is',result)//result is Object { name: "普通酒", category: "酒水", weight: "100kg" }

    // 深拷贝
    // function deepClone(obj){
    // 	if(typeof obj === 'object'){
    // 		let newobj = {}
    // 		for(let i in obj){
    // 			// 把属性值递归循环
    // 			newobj[i] = deepClone(obj[i])
    // 		}
    // 		return newobj
    // 	}else{
    // 		return obj
    // 	}
    // }
    // const resultdeep = deepClone(goods)
    // console.log('resultdeep is',resultdeep)

    // 考虑数组,添加一个三元判断
    // function deepclonewitharray(target) {
    //     if (typeof target === 'object') {
    //         let cloneTarget = Array.isArray(target) ? [] : {};
    //         for (const key in target) {
    //             cloneTarget[key] = deepclonewitharray(target[key]);
    //         }
    //         return cloneTarget;
    //     } else {
    //         return target;
    //     }
    // };
    // const deepresultwitharray = deepclonewitharray(goods)
    // console.log('deepresultwitharray is',deepresultwitharray)

 /*js对象继承*/
/*1.原型链继承*/
    //Box()构造,被继承的函数叫做超类型（父类,基类）
    // function Box(){
    //     this.name = '张三';
    // }
    // Box.prototype.sayName = function (){
    //     console.log(`我是父类原型上定义的方法${this.name}`)
    // }
    // //Desk()构造,继承的函数叫做子类型（子类,派生类）
    // function Desk(){
    //     this.age = 23;
    // }
    // // 实现继承 Box
    // Desk.prototype = new Box();
    // // 必须在原型赋值之后才能添加或重写方法
    // Desk.prototype.deskTalk = function (){
    //     console.log('hello desk')
    // }
    // let desk = new Desk();
    // console.log('desk.age is',desk.age);
    // console.log('desk.name is',desk.name);//继承来的属性
    // desk.sayName();//继承来的方法
    // function Table(){//Table()构造
    //     this.level='aaaaaa';
    // }
    // Table.prototype = new Desk();
    // let table= new Table();
    // console.log('table.name is',table.age);//继承了Desk的age
    // console.log('table.name is',table.name);//继承了Box的name
    // table.sayName();//继承来的方法

/*2.对象冒充继承*/
    //使用对象冒充继承,只能继承构造函数里的信息,不能继承原型中的。解决传参问题
    // function Box(name,age){
    //     this.name = name;
    //     this.age = age;
    //     this.family = ['哥哥','姐姐','弟弟',];
    //     this.sayHi = function(){
    //         console.log(`hi${this.name}`)
    //     }
    // }
    // Box.prototype.family = '家庭';
    // Box.prototype.sayName = function(){
    //     console.log(`hello${this.name}`)
    // };

    // function Desk(name,age){
    //     //对象冒充继承且可以给父类构造函数传参
    //     Box.call(this,name,age);
    // }
    // let desk1 = new Desk('wang',23);
    // desk1.family.push("妹妹");
    // console.log(desk1.family)//[ "哥哥", "姐姐", "弟弟", "妹妹" ]
    // console.log(desk1.name)//'wang'
    // desk1.sayHi()//只能访问构造函数内的方法
    // desk1.sayName()//desk1.sayName is not a function
    // console.log(desk1.age)//23
    // let desk2 = new Desk('qiao',22);
    // console.log(desk2.family)// [ "哥哥", "姐姐", "弟弟" ]
    // console.log(desk2.name)//'qiao'
    // console.log(desk2.age)//22
    // desk2.sayHi()//只能访问构造函数内的方法
    // desk2.sayName()//desk2.sayName is not a function

/*3.组合继承*/
//组合继承:原型链+借用构造函数的模式,解决了构造问题,传参问题
    // function Box(age){
    //     this.name=['wang','pan','Hello']
    //     this.age=age;
    // }
    // Box.prototype.run = function(){
    //     return this.name  +  this.age +  '运行中....';
    // };

    // function Desk(age){
    //     //对象冒充,继承实例属性
    //     Box.call(this,age);
    // }
    // //原型链继承,继承原型方法
    // Desk.prototype = new Box();
    // //修正构造器属性指向
    // Desk.prototype.constructor = Desk
    // Desk.prototype.sayAge = function(){
    //     return this.age
    // };
    // let desk1 = new Desk(23);
    // desk1.name.push('zhangsan')
    // console.log(desk1.name)//[ "wang", "pan", "Hello", "zhangsan" ]
    // console.log(desk1.run());//wang,pan,Hello23运行中....
    // console.log(desk1.sayAge());//23

    // let desk2 = new Desk(27);
    // console.log(desk2.name)// [ "wang", "pan", "Hello" ]
    // console.log(desk2.run());//wang,pan,Hello27运行中....
    // console.log(desk2.sayAge());//27

    // console.log(desk1 instanceof Desk)//true
    // console.log(desk1 instanceof Box)//true
    // console.log(desk1 instanceof Object)//true

    // console.log(Object.prototype.isPrototypeOf(Box))
    // console.log(Box.prototype.isPrototypeOf(desk1))
    // console.log(Desk.prototype.isPrototypeOf(desk1))

/*4.原型式继承*/
    // let person = {
    //     name:"zhangsan",
    //     friends:["lisi","wangwu","maliu"]
    // }
    // // 原型式继承
    // function object(obj){
    //     function F() {};
    //     F.prototype = obj;
    //     return new F();
    // }
    // let objectPerson = object(person)
    // let anothorPerson1 = Object.create(person,{
    //     name:{
    //         value:'anothor1'
    //     }
    // })
    // anothorPerson1.friends.push("rob")
    // let anothorPerson2 = Object.create(person,{
    //     name:{
    //         value:'anothor2'
    //     }
    // })
    // anothorPerson2.friends.push("bab")
    // console.log(person.friends)// [ "lisi", "wangwu", "maliu", "rob", "bab" ]

/*5.寄生式继承*/
    // let person = {
    //     name:"zhangsan",
    //     friends:["lisi","wangwu","maliu"]
    // }
    // function createAnothor(original){
    //     let clone = Object.create(original);
    //     clone.sayHi = function(){
    //         console.log(`hi`)
    //     }
    //     return clone;
    // }
    // // 继承
    // let anothor = createAnothor(person);
    // console.log(anothor.name)//zhangsan
    // anothor.sayHi()//hi

/*6.寄生式组合继承*/
    // function Box(age){
    //     this.names=['wang','pan','Hello']
    //     this.age=age;
    // }
    // Box.prototype.run = function(){
    //     return this.names  +','+  this.age +','+ '父类原型run方法运行中....';
    // };

    // function Desk(age){
    //     //对象冒充,继承实例属性、给父类构造传参
    //     Box.call(this,age);
    // }
    // //不再使用这个方法
    // // Desk.prototype = new Box();
    // // 使用寄生式继承
    // function inheritPrototype(subType,superType){
    //     // 子类原型等于父类原型的一个副本
    //     subType.prototype = Object.create(superType.prototype);//创建对象
    //     subType.prototype.constructor = subType;//重新指定constructor属性,增强对象
    // }
    // // 继承
    // inheritPrototype(Desk,Box);
    // Desk.prototype.sayAge = function(){
    //     return this.age
    // };
    // let desk1 = new Desk(23);
    // desk1.names.push('zhangsan')
    // console.log(desk1.names)//[ "wang", "pan", "Hello", "zhangsan" ]
    // console.log(desk1.run());//wang,pan,Hello,zhangsan,23,父类原型run方法运行中....
    // console.log(desk1.sayAge());//23
    // console.log(desk1 instanceof Desk)//true
    // console.log(desk1 instanceof Box)//true
    // console.log(desk1 instanceof Object)//true
    // let desk2 = new Desk(27);
    // console.log(desk2.names)// [ "wang", "pan", "Hello" ]
    // console.log(desk2.run());//wang,pan,Hello,27,父类原型run方法运行中....
    // console.log(desk2.sayAge());//27

/*7.ECMAScript类继承*/
    // es6继承
    // class Person{
    //     constructor(name,age){
    //         this.name = name;
    //         this.age = age;
    //     }
    //     showName(){
    //         console.log("调用父类的方法:",this.name,this.age);
    //     }
    // }
    // let person = new Person('zangqingan',24);
    // console.log(person);//Object { name: "zangqingan", age: 24 }
    // person.showName()//调用父类的方法: zangqingan 24

    // //子类,使用extends继承父类
    // class Studend extends Person{   
    //     constructor(name,age,salary){
    //         super(name,age);//继承父类实例属性并给父类传参
    //         this.salary =salary;
    //     }
    //     //重写继承来的一般方法
    //     showName(){
    //         console.log("调用子类重写的方法：",this.name,this.age,this.salary);
    //     }
    // }
    // let studend = new Studend('wanggeng',24,100);
    // console.log(studend);//Object { name: "wanggeng", age: 24, salary: 100 }
    // //子类使用继承来的方法
    // studend.showName();//调用子类重写的方法： wanggeng 24 100

/*8.多重继承*/
    // // es5
    // function M1() {
    //     this.hello = 'hello';
    // }
    // function M2() {
    //     this.world = 'world';
    // }
    // function S() {
    //     M1.call(this);
    //     M2.call(this);
    // }
    // 继承 M1
    // S.prototype = Object.create(M1.prototype);
    // // 继承链上加入 M2
    // Object.assign(S.prototype, M2.prototype);
    // // 指定构造函数
    // S.prototype.constructor = S;
    // let s = new S();
    // console.log( s.hello )// 'hello'
    // console.log( s.world )// 'world'

    // es6
    function mix(...mixins) {
        class Mix {
            constructor() {
            // 遍历传入的参数列表
            for (let mixin of mixins) {
                copyProperties(this, new mixin()); // 拷贝实例属性
            }
            }
        }
        
        for (let mixin of mixins) {
            copyProperties(Mix, mixin); // 拷贝静态属性
            copyProperties(Mix.prototype, mixin.prototype); // 拷贝原型属性
        }
        // 返回整合后的类
        return Mix;
    }
    // 复制属性
    function copyProperties(target, source) {
        for (let key of Reflect.ownKeys(source)) {
            // 不复制构造方法、原型、name属性
            if ( key !== 'constructor' && key !== 'prototype'&& key !== 'name') {
                // 获取每个属性的属性描述对象
                let desc = Object.getOwnPropertyDescriptor(source, key);
                // 给目标对象复制一份
                Object.defineProperty(target, key, desc);
            }
        }
    }
    // 使用
    class Loggable {}
    class Serializable {}
    class DistributedEdit extends mix(Loggable, Serializable) {
    // ...
    }

}
</script>
</body>
</html>