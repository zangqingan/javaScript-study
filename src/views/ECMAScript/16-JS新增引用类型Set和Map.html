<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>JavaScript新增引用类型Set和Map</title>
    <link href="../../assets//styles/index.css" rel="stylesheet"></link>
</head>
<body>
    <div class="content">
        <h3>1、Set集合</h3>
        <div>
            <h4>1.Set类型概述</h4>
            <pre>
                ES6 提供了一种新的集合类型 Set,为JavaScript带来了集合数据结构。
                它类似于数组,但是成员的值都是唯一的,没有重复的值。它可以包含任何JavaScript数据类型的值。
                打印出来是:Set(5) [ 2, 3, 5, 4, "username" ]这样的。
                因为是集合类型所以 typeof 运算符还是返回 "object"。
            </pre>
            <h4>2.创建方法</h4>
            <pre>
                Set本身是一个构造函数,接受一个数组(或者具有 iterable 接口的其他数据结构即可迭代对象)作为参数,用来初始化Set类型的数据结构。
                语法:
                    const s = new Set(可迭代对象);
                如: const s = new Set([2, 3, 5, 4, 5, 2, 2]);
                可以通过实例方法 add()方法向 Set 结构加入成员,has()方法查询,size属性取得元素数量,delete()和clear()方法删除元素。
            </pre>
            <h4>3.Set类型常用的实例属性和方法</h4>
            <div>
                <h5>1.实例属性</h5>
                <pre>
                    1. Set.prototype.constructor:构造函数,默认就是Set函数。
                    2. Set.prototype.size:返回Set实例的成员总数。
                    // Set
                    const set = new Set([1, '集合', 3, 4, 4])
                    console.log(set)// Set(0)  { 1=> 1,集合=> 集合,3=> 3,4=> 4}
                    console.log(typeof set)// object
                    console.log(set.constructor) // f Set(){}
                    console.log(set.size) // 4
                </pre>
                <h5>2.操作方法</h5>
                <pre>
                    操作方法(用于操作数据)
                    四个操作方法。
                    1. Set.prototype.add():添加某个值,返回 Set 结构本身。
                    2. Set.prototype.has():返回一个布尔值,表示该值是否为Set的成员。
                    3. Set.prototype.delete():删除某个值,返回一个布尔值,表示删除是否成功。
                    4. Set.prototype.clear():清除所有成员,没有返回值。
                    // Set-操作方法
                    const set = new Set([1, '集合', 3, 4, 4])
                    set.add('我是添加的成员')
                    console.log(set)// Set(5) {1 => 1,集合 => 集合,3 => 3,4 => 4,我是添加的成员 => 我是添加的成员}
                    console.log(set.has('集合'))//true
                    console.log(set.has('集合1'))//false
                    console.log(set.delete('集合'))// true
                    console.log(set)//  Set(4) {1 => 1,3 => 3,4 => 4,我是添加的成员 => 我是添加的成员}
                    set.clear()
                    console.log(set) // Set(0) {}
                </pre>
                <h5>3.遍历方法</h5>
                <pre>
                    和遍历方法(用于遍历成员),遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。
                    四个遍历方法:
                    1. Set.prototype.keys():返回键名的遍历器(Set数据结构没有键名或者说键名和键值一样)所以返回值和values完全一致。
                    2. Set.prototype.values():返回键值的遍历器
                    3. Set.prototype.entries():返回键值对的遍历器
                    4. Set.prototype.forEach():使用回调函数遍历每个成员
                    Set实例默认就是可遍历的同时默认就是使用values方法。
                    // Set-遍历方法
                    const set = new Set(['red', '集合', true, 4, 4])
                    for(let key of set.keys()) {
                        console.log('key',key)
                    }
                    // key red
                    // key 集合
                    // key true
                    // key 4
                    for (let key of set.values()) {
                        console.log('key', key)
                    }
                    // key red
                    // key 集合
                    // key true
                    // key 4
                    for (let key of set.entries()) {
                        console.log('key', key)
                    }
                    // key Array(2)[ red, red]
                    // key Array(2)[ 集合, 集合]
                    // key Array(2)[ true, true]
                    // key Array(2)[ 4, 4]
                    set.forEach((value,key) => {
                        console.log(key,value)
                    })
                    // red red
                    // 集合 集合
                    // true true
                    // 4 4
                </pre>
            </div>
            <h4>4.Set类型的应用</h4>
            <pre>
                可以使用Array.from()方法或者使用 ...展开运算符(它内部使用的是for of循环)将 Set 结构转为真正的数组,
                利用set值都是唯一的可以去除数组的重复成员。
                // Set-应用
                const arr = ['red',23,'red',6,23,'green',true]
                // 使用扩展运算符结合set去重，这是因为扩展运算符内部使用的是for of 循环
                const newArr = [...new Set(arr)]
                console.log('newArr', newArr)// Array(5)['red',23,6,green',true]
                // 使用Array.from数组去重函数
                function dedAarray(array) {
                    return Array.from(new Set(array))
                }
                const result = dedAarray(arr)
                console.log('result', result)// result Array(5)['red',23,6,green',true]
            </pre>
            <h4>5.WeakSet</h4>
            <pre>
                弱类型的Set、结构和用法跟Set类似区别在于: 
                1.WeakSet 的成员只能是对象和Symbol值而不能是其它类型的值。
                2.WeakSet 中的对象成员都是弱引用、其它对象不再引用时JavaScript的垃圾回收机制就会自动回收该对象所占用的内存空间。
                3.WeakSet因为成员都是弱引用所有不能遍历。
            </pre>
        </div>
        <h3>2. Map映射</h3>
        <div>
            <h4>1.Map类型概述</h4>
            <pre>
                js的对象是键值对的集合(Hash 结构)只能使用字符串当作键,为了解决这个问题。
                ES6 提供了一种新的集合类型 Map 数据结构,它类似于对象,也是键值对的集合,但是“键”的范围不限于字符串而是各种类型的值(包括对象)都可以当作键。
                也就是说,Object 结构提供了“字符串—值”的对应,而Map 提供了“值—值”的对应,是一种更完善的 Hash 结构实现。<br>
                <b>1:Maps 和 Objects 的区别比较:</b>
                一个 Object 的键只能是字符串或者 Symbols,但一个 Map 的键可以是任意值。
                Map 中的键值是有序的(FIFO 原则),而添加到对象中的键则不是。
                Map 的键值对个数可以从 size 属性获取,而 Object 的键值对个数只能手动计算。
                Object 都有自己的原型,原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。<br>
                打印出来是:Map { name → "张三", title → "Author" }这样。
            </pre>
            <h4>2.创建方法</h4>
            <pre>
                Map本身也是一个构造函数,接收一个包含键值对数组的可迭代对象。
                语法:
                    let myMap = new Map(可迭代对象);
                如: let m = new Map();
                可以通过实例方法 set()方法向 Map结构添加键值对,get()和has()方法查询,size属性取得键值对的数量,delete()和clear()方法删除元素。
            </pre>
            <h4>3.Map类型常用的实例属性和方法</h4>
            <div>
                <h5>1.实例属性</h5>
                <pre>
                    1.size:返回 Map 结构的成员总数。
                </pre>
                <h5>2.操作方法</h5>
                <pre>
                    操作方法(用于操作数据)
                    5个操作方法。
                    1.set():设置键名key对应的键值为value,然后返回整个 Map 结构。如果key已经有值,则键值会被更新,否则就新生成该键。可以采用链式写法
                    2.get():读取key对应的键值,如果找不到key,返回undefined。
                    3.has():返回一个布尔值,表示某个键是否在当前 Map 对象之中。
                    4.delete():删除某个键,返回true。如果删除失败,返回false。
                    5.clear():清除所有成员,没有返回值。
                    // Map-操作方法
                    const map = new Map()
                    map.set('foo', true);
                    map.set('bar', false);
                    map.set('edition', 6)        // 键是字符串
                    map.set(262, 'standard')     // 键是数值
                    map.set(undefined, 'nah')    // 键是 undefined
                    const hello = function () { console.log('hello'); };
                    map.set(hello, 'Hello ES6!') // 键是函数
                    console.log(map.size)// 6
                    console.log(map.get(hello))// Hello ES6!
                    console.log(map.get(262))// standard
                    console.log(map.get('ff'))// undefined
                    console.log(map.delete('foo'))
                    console.log(map)// Map(5){bar=> false,edition=> 6,262=> standard,undefined=> nah,f()=> Hello ES6!}
                </pre>
                <h5>3.遍历方法</h5>
                <pre>
                    和遍历方法(用于遍历成员),Map 的遍历顺序是插入顺序(FIFO 原则)。
                    四个遍历方法:
                    1.keys():返回键名的遍历器
                    2.values():返回键值的遍历器
                    3.entries():返回键值对的遍历器
                    4.forEach():使用回调函数遍历每个成员
                    // Map-遍历方法
                    const hello = function () { console.log('hello'); };
                    const map = new Map()
                    map.set('foo', true);
                    map.set('bar', false);
                    map.set('edition', 6)        // 键是字符串
                    map.set(262, 'standard')     // 键是数值
                    map.set(undefined, 'nah')    // 键是 undefined
                    map.set(hello, 'Hello ES6!') // 键是函数
                    console.log(map)// Map(6){foo=>true,bar=>false,edition=>6,262=>standard,undefined=>nah,f()=>Hello ES6!}
                    for (let key of map.keys()) {
                        console.log(key);
                    }
                    // foo
                    // bar
                    // edition
                    // 262
                    // undefined
                    // f(){ … }
                    for (let value of map.values()) {
                        console.log(value);
                    }
                    // true
                    // false
                    // 6
                    // standard
                    // nah
                    // Hello ES6!
                    for (let item of map.entries()) {
                        console.log(item);
                    }
                    // Array(2)[foo,true]
                    // Array(2)[bar,false]
                    // Array(2)[edition,6]
                    // Array(2)[262,standard]
                    // Array(2)[undefined,nah]
                    // Array(2)[f(){ … },Hello ES6!]
                    map.forEach((value,key) => {
                        console.log(key,value)
                    })
                    // foo true
                    // bar false
                    // edition 6
                    // 262 standard
                    // undefined nah
                    // f(){ … } Hello ES6!
                </pre>
            </div>
            <h4>4.Map类型的应用</h4>
            <pre>
                当判断的条件很多时可以把判断的条件以及对应的结果收集起来作为一个二维数组传递给Map结构、然后通过Map的实例方法get获取指定条件对应的值如果找不到就返回undefined。
                const currentColor = 'red'
                const activeColorMap = new Map([
                    ['red', 'red-level'],
                    ['orange', 'orange-level'],
                    ['yellow', 'yellow-level'],
                    ['green', 'green-level']
                ])
                // 本质是遍历传入的二维数组并用map设置对应的键值对
                二维数组.forEach(
                    ([key, value]) => map.set(key, value)
                  );
                if (activeColorMap.get(currentColor)) {
                    return activeColorMap.get(currentColor)
                }
                // 使用对象动态属性也是可以的
                const obj = {
                    'red': 'red-level',
                    'orange': 'orange-level',
                    'yellow': 'yellow-level',
                    'green': 'green-level',
                }
                if (obj[currentColor]) {
                    console.log(obj[currentColor])
                }
            </pre>
            <h4>5. WeakMap </h4>
            <pre>
                弱类型的Map、结构和用法跟Map类似区别在于:
                1.WeakMap值接收对象和Symbol值作为键名而不能是其它类型的值。
                2.WeakMap的键名所指向的对象也不计入垃圾回收机制、只要没有其它对象引用就会自动回收该对象所占用的内存空间。
                3.WeakMap对键名是弱引用的所有也不能遍历。
            </pre>
        </div>

    </div>
<!-- js -->
<script>
window.onload = function(){
/*Set的用法*/
    // 初始化和api使用
    // const s = new Set();
    // let arr = [2, 3, 5, 4, 5, 2, 2]
    // arr.forEach(x => s.add(x));
    // for (let i of s) {
    //     console.log(i);
    // }
    // console.log(typeof s)//object
    // console.log(s.size)//4
    // console.log(s.add('username'))//Set(5) [ 2, 3, 5, 4, "username" ]
    // console.log(s.keys())
    // console.log(s.values())
    // console.log(s.entries())
    // s.forEach(v => {
    //     console.log(v)
    // })
    // // 和forEach等价
    // for(let i of s){
    //     console.log(i)
    // }
    
    // 去除数组的重复成员
    // const items = [1, 2, 3, 4, 5, 5, 5, 5];
    // let arr2 = [...new Set(items)]
    // console.log(arr2)//Array(5) [ 1, 2, 3, 4, 5 ]


 /*Map的基本用法*/
    // const m = new Map();
    // const o = {str: 'Hello World'};

    // console.log(m);//Map(0)
    // console.log(typeof m);//object
    // console.log(m.set(o, 'content'));//Map { {…} → "content" }使用 Map 结构的set方法,将对象o当作m的一个键(属性名)
    // console.log(m.get(o));//使用get方法读取o这个键返回值是对应的属性值:content,
    // console.log(m.has(o));//true
    // console.log(m.size)
    // console.log(m.delete(o));//true使用delete方法删除了这个键。
    // console.log(m.has(o));//false
    
    // //Map 接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。
    // const map = new Map([
    //     ['name', '张三'],
    //     ['title', 'Author']
    // ]);
    // console.log(map)//Map { name → "张三", title → "Author" }
    // console.log( map.size);//2,返回Map 结构的成员总数。
    // console.log(map.has('name'));//true
    // console.log(map.get('name'));//张三
    // console.log(map.has('title'));//true
    // console.log(map.get('title'));//Author
    // console.log(map.keys())
    // console.log(map.values())
    // console.log(map.entries())
    // map.forEach((k,v) => {
    //     console.log(k,v)
    // })
    // for(let [k,v] of map){
    //     console.log(k,v)
    // }

    //遍历练习
    // const map = new Map([
    //     ['F', 'no'],
    //     ['T',  'yes'],
    // ]);

    // for (let key of map.keys()) {
    //     console.log(key);
    // }
    // "F"
    // "T"

    // for (let value of map.values()) {
    //     console.log(value);
    // }
    // "no"
    // "yes"

    // for (let item of map.entries()) {
    //     console.log(item[0], item[1]);
    // }
    // "F" "no"
    // "T" "yes"

    // 或者使用变量解构赋值
    // for (let [key, value] of map.entries()) {
    //     console.log(key, value);
    // }
    // "F" "no"
    // "T" "yes"

    // 等同于使用map.entries()
    // for (let [key, value] of map) {
    //     console.log(key, value);
    // }
    // "F" "no"
    // "T" "yes"

    // map.forEach(function(value, key, map) {
    //     console.log("Key: %s, Value: %s", key, value);
    // });
}
</script>
</body>
</html>