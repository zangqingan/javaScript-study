<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>BOM综合</title>
    <link href="../../assets//styles/index.css" rel="stylesheet"></link>
</head>
<body>
    <div  class="content">
        <h3>1、BOM概述</h3>
        <div>
            <h4>1.概述</h4>
            <pre>
                
                BOM(Browser Object Model)浏览器对象模型
                它提供了与网页无关的浏览器功能对象以及各种接口,让 JavaScript 脚本可以控制浏览器的各种功能。
                一旦网页内嵌了JavaScript脚本代码、浏览器加载网页就会执行脚本进而达成操作浏览器的目的、实现交互。

                BOM是没有规范的,而是把各个厂商之间浏览器共通的部分变成既定事实标准。
                主要包括以下几个方面的内容:
                    BOM提供的一些常用对象、
                    客户端存储、
                    网络请求与远程资源、
                    异步编程、
                    错误处理与调试等。
            </pre>
        </div>   
        <h3>2、BOM提供的常见对象</h3>
        <div>
            <h4>1. window对象</h4>
            <div>
                <h5>1. 概述</h5>
                <pre>
                    在ECMA-262规范里规定了JavaScript的全局兜底对象为Global对象,它是一个很特别的对象,因为代码不能显示地访问它。
                    但是各个厂商的浏览器都把window对象作为Global对象的代理,所以可以认为在浏览器环境里JavaScript的全局对象Global就是window对象。
                    window对象就是指当前的浏览器窗口实例也是当前页面最高一层的对象,所有其它对象都是它的下属。

                    JavaScript中很多其它属性、方法和对象都是暴露在window对象上的,不过在访问它们时一般又将window省略直接访问。
                </pre>
                <h5>2. window对象常用属性</h5>
                <pre>

                    1.窗口关系
                        1.window.top属性指向最顶层窗口,主要用于在框架窗口(frame)里面获取顶层窗口。
                        2.window.parent属性指向父窗口。如果当前窗口没有父窗口,window.parent指向自身。
                        if (window.parent !== window.top) {
                            // 表明当前窗口嵌入不止一层
                        }
                    
                    2.窗口位置和大小
                        返回window对象的位置信息和大小信息。
                        1.window.screenX/screenY,返回浏览器窗口左上角相对于当前屏幕左上角的水平距离和垂直距离(单位像素)。这两个属性只读。
                        2.window.screenLeft/screenTop,放回浏览器窗口相对于屏幕左侧和顶部的位置距离。
                        3.window.innerHeight/innerWidth,返回网页在当前窗口中可见部分的高度和宽度,即“视口”(viewport)的大小(单位像素)。这两个属性只读。
                        4.window.outerHeight/outerWidth,返回浏览器窗口的高度和宽度,包括浏览器菜单和边框(单位像素)。这两个属性只读。

                    3.全局对象属性
                        全局对象属性指向一些浏览器原生的全局对象。
                        1.window.document:指向document对象,注意,这个属性有同源限制。只有来自同源的脚本才能读取这个属性。
                        2.window.navigator:指向Navigator对象,用于获取环境信息,即当前当前用户的浏览器和系统的信息。
                        3.window.screen:指向Screen对象,表示用户的屏幕信息。
                        4.window.history:指向History对象,表示浏览器的浏览历史,可以通过该对象来操作浏览器的历史纪录。
                        5.window.location:指向Location对象,用于获取当前浏览器的地址栏 URL 信息。它等同于document.location属性。
                        6.window.localStorage:指向本地储存的 localStorage 数据。
                        7.window.sessionStorage:指向本地储存的 sessionStorage 数据。
                        8.window.console:指向console对象,用于操作控制台。
                    注意: 这些全局对象都是作为window对象的属性保存的,使用时window 一般会省略。
                </pre>
                <h5>3. window对象常用方法</h5>
                <pre>

                    1.window.alert()、警告弹窗
                    2.window.prompt()、提示输入弹窗,返回值是输入内容,取消为null。
                    3.window.confirm()、确认信息弹窗
                    这三个都是浏览器与用户互动的全局方法。它们会弹出不同的对话框,要求用户做出回应。
                    注意,这三个方法弹出的对话框,都是浏览器统一规定的式样,无法修改。

                    4.window.open()、新建另一个浏览器窗口,类似于浏览器菜单的新建窗口选项、一共可以接受三个参数。
                    5.window.close()、用于关闭当前窗口
                </pre>
                <h5>4. window对象常用事件</h5>
                <pre>

                    window 对象也是实现了 DOM事件模型内置的相关接口的所以也可以使用相关的方法
                    比较常用的就是二个: 加载事件 load、窗口大小改变事件 resize
                    1. load 事件
                    2. resize 事件
                </pre>
            </div>
            <h4>2. navigator对象</h4>
            <pre>

                1.概述
                    navigator对象是挂载window对象下的一个属性对象、可以省略window直接访问。
                    由网景的Navigator2浏览器最早引入的,现在成为客户端标识浏览器的标准。
                    它是用来获取环境信息,即当前用户的浏览器和系统信息,通过这个对象可以识别不同的浏览器类型。 

                2.navigator对象常用属性(大部分属性已经没什么用了)
                    1.navigator.userAgent属性,返回浏览器的 User Agent 字符串,表示浏览器的厂商和版本信息。
                    它是一个字符串包含了用来描述浏览器信息的内容。
                    注意:ie11中已经将微软和ie相关的标识都去除了,所以不能通过这个属性来识别了。
                    2.navigator.appName 浏览器名字
                    3.navigator.plugins 属性返回一个类似数组的对象,成员是 Plugin 实例对象,用来检测浏览器安装了哪些插件。
            </pre>
            <h4>3. screen对象</h4>
            <pre>

                1.概述
                    screen 对象是挂载window对象下的一个属性对象、可以省略window直接访问。
                    它表示当前窗口所在的屏幕信息,通过这个对象可以获取到用户显示器的相关信息。
                    很少用到,因为每个厂商的浏览器都暴露了不同的属性。

                2.screen对象常用属性
                    1.screen.height:浏览器窗口所在的屏幕的高度(单位像素)。
                        除非调整显示器的分辨率,否则这个值可以看作常量,不会发生变化。
                        显示器的分辨率与浏览器设置无关,缩放网页并不会改变分辨率。

                    2.screen.width:浏览器窗口所在的屏幕的宽度(单位像素)。

                    3.screen.availHeight:浏览器窗口可用的屏幕高度(单位像素)。
                        因为部分空间可能不可用,比如系统的任务栏或者 Mac 系统屏幕底部的 Dock 区,这个属性等于height减去那些被系统组件的高度。

                    4.screen.availWidth:浏览器窗口可用的屏幕宽度(单位像素)。
                    可以根据屏幕的宽度,将用户导向不同网页的代码。
                    if ((screen.width <= 800) && (screen.height <= 600)) {
                        window.location.replace('small.html');
                    } else {
                        window.location.replace('wide.html');
                    }
            </pre>
            <h4>4. history对象</h4>
            <div>
                <h5>1. 概述</h5>
                <pre>
                    它也是挂载在window对象下的对象属性、表示当前浏览器窗口首次使用以来用户的浏览历史纪录。
                    即 History 对象保存了当前窗口访问过的所有页面的网址。
                    但是由于安全原因,浏览器不允许脚本读取这些地址,所以这个对象不会暴露保存的用户浏览历史的具体URL,只是允许在地址之间导航(切换)。
                    (不能获取到具体的历史纪录,只能操作浏览器向前或向后。且第一次有效,关闭页面后就没了)
                    浏览器里前进、后退、刷新按钮其实就是对History对象进行操作。
                </pre>
                <h5>2. history对象常用属性和方法</h5>
                <pre>

                    1.history.length,当前窗口访问过的网址数量
                    2.history.go():跳转到指定页面,参数:是一个整数,正数向前跳转,负数向后跳转。
                    如果不指定参数,默认go(0)相当于刷新当前页面,go(1)相当于forward(),go(-1)相当于back()。
                    3.history.back():回退到上一个页面网址,等同于点击浏览器的后退键。对于第一个访问的网址,该方法无效果。
                    4.history.forward():跳转下一个页面网址,等同于点击浏览器的前进键。对于最后一个访问的网址,该方法无效果。
                </pre>
                <h5>3. HTML5标准新增history对象状态管理特性</h5>
                <pre>

                    hashchange事件解决了用户刷新页面不用发送Ajax请求的问题,它是在页面url的哈希散列值发生变化是触发。
                    而HTML5新增history对象状态管理特性API就是让开发者可以改变浏览器url但是又不会刷新页面。
                    1.history.pushState(),向历史记录栈中添加一条状态记录消息。
                    2.history.replaceState(),修改历史栈中的一条记录
                </pre>
            </div>
            <h4>5. location对象</h4>
            <div>   
                <h5>1.概述</h5>
                <pre>

                    BOM提供对象最有用之一了,提供了当前浏览器窗口中加载文档的信息,也提供了与 URL 相关的信息和操作方法。
                    它的独特之处在于:它既是window对象的属性,也是document对象的属性。
                    也就是window.location和document.location指向的是同一个对象,也都可以拿到这个location对象。

                </pre>
                <h5>2.location对象常用属性</h5>
                <pre>

                    location对象又提供以下属性用来把URL解析为离散片段后能够通过location对象属性的形式来访问。
                        1.location.href:整个 URL。写入新的 URL 地址,浏览器会立刻跳转到这个新地址。
                        经常使用这个属性修改浏览器地址达到跳转页面的效果。
                        2.location.origin:URL 的协议、主机名和端口。
                        3.location.protocol:当前 URL 的协议,包括冒号(:)。
                        4.location.host:主机。如果端口不是协议默认的80和433,则还会包括冒号(:)和端口。
                        5.location.hostname:主机名,不包括端口。
                        6.location.port:端口号。
                        7.location.pathname:URL 的路径部分,从根路径/开始。
                        8.location.search:查询字符串部分,从问号?开始。
                        9.location.hash:片段字符串部分,从#开始。
                        10.location.username:域名前面的用户名。
                        11.location.password:域名前面的密码。     
                    注意:这些属性里面,只有origin属性是只读的,其他属性都可读写。
                    例子:
                    // 当前网址为 http://user:passwd@www.example.com:4097/path/a.html?x=111#part1
                    document.location.href
                    // "http://user:passwd@www.example.com:4097/path/a.html?x=111#part1"
                    document.location.protocol
                    // "http:"
                    document.location.host
                    // "www.example.com:4097"
                    document.location.hostname
                    // "www.example.com"
                    document.location.port
                    // "4097"
                    document.location.pathname
                    // "/path/a.html"
                    document.location.search
                    // "?x=111"
                    document.location.hash
                    // "#part1"
                    document.location.username
                    // "user"
                    document.location.password
                    // "passwd"
                    document.location.origin
                    // "http://user:passwd@www.example.com:4097"
                </pre> 
                <h5>3.location对象常用方法</h5>
                <pre>

                    1.location.assign(),接受一个 URL 字符串作为参数,使得浏览器立刻跳转到新的 URL。
                    如果参数不是有效的 URL 字符串,则会报错。

                    2.location.replace(),接受一个 URL 字符串作为参数,使得浏览器立刻跳转到新的 URL。
                    如果参数不是有效的 URL 字符串,则会报错。同时它会删除当前网址,导致不能后退了。

                    3.location.reload(),reload方法使得浏览器重新加载当前网址,相当于按下浏览器的刷新按钮。
                    它接受一个布尔值作为参数,true将向服务器重新请求这个网页,false从本地缓存重新加载该网页。
                </pre>   
            </div>
            <h4>6. URL对象</h4>
            <div>
                <h5>1.概述</h5>
                <pre>

                    URL(Uniform Resource Locator)统一资源定位符的简写,它是万维网的统一资源定位标志,就是指网络地址。
                    它是互联网的基础设施之一,浏览器除了提供location对象用来管理 URL外。
                    还原生提供了 URL 对象,它是一个构造函数可以用来构造、解析和编码 URL。
                    它也是挂载window对象下的、通过window.URL可以拿到这个构造函数。
                </pre>
                <h5>2. URL的组成</h5>
                <pre>

                    网页的 URL 只能包含合法的字符。合法字符分成两类。
                    URL 元字符:分号(;)、逗号(,)、斜杠(/)、问号(?)、冒号(:)、at(@)、&、等号(=)、加号(+)、美元符号($)、井号(#)。
                    语义字符:a-z、A-Z、0-9、连词号(-)、下划线(_)、点(.)、感叹号(!)、波浪线(~)、星号(*)、单引号(')、圆括号(())。
                    除了以上字符、其他字符出现在 URL 之中都必须进行转义不然报错。

                    URL组成:协议、主机、端口、路径
                        'http://example.com:8080/index.html#part1'
                        protocol :// hostname[:port] / path / [:parameters][?query]#fragment
                        protocol:协议,指定底层使用的协议(例如:http,https,ftp等等)
                        hostname:主机名,HTTP服务器的IP地址或者域名(本机就是localhost或者127.0.0.1)
                        :port:端口号,HTTP服务器的默认端口是80,这种情况下端口号可以省略,如果使用了别的端口,必须指明,例如http://www.biadu.com:8080/
                        path:由零或多个“/”符号隔开的字符串,一般用来表示主机上的一个目录或文件地址。
                        parameters,动态参数
                        query:查询字符串即要发送给Web服务器的数据,可有多个参数,用“&”符号隔开,每个参数的名和值用“=”符号隔开。
                        fragment:哈希值
                        主要是三个: 
                            :parameters表示动态参数
                            ?key=value&key=value 查询字符串
                            #fragment hash值
                </pre>
                <h5>3. URL编码与解码方法</h5>
                <pre>

                    不是合法字符出现在url时必须转义,转义规则是根据操作系统的默认编码,将每个字节转为百分号（%）加上两个大写的十六进制字母。
                    JavaScript 为此提供了四个全局对象window对象下的 URL 的编码/解码方法。
                        1. window.encodeURI()方法用于转码整个 URL。它的参数是一个字符串,代表整个 URL。它会将元字符和语义字符之外的字符,都进行转义。
                            encodeURI('http://www.example.com/q=春节')
                            // "http://www.example.com/q=%E6%98%A5%E8%8A%82"

                        2. window.decodeURI()方法用于整个 URL 的解码。它是encodeURI()方法的逆运算。它接受一个参数,就是转码后的 URL。
                            decodeURI('http://www.example.com/q=%E6%98%A5%E8%8A%82')
                            // "http://www.example.com/q=春节"
                            
                        3. window.encodeURIComponent()方法用于转码 URL 的组成部分,会转码除了语义字符之外的所有字符,即元字符也会被转码。
                        所以,它不能用于转码整个 URL会报错。它接受一个参数,就是 URL 的其中一个片段。

                        4. window.decodeURIComponent()用于URL 片段的解码。它是encodeURIComponent()方法的逆运算。
                        它接受一个参数,就是转码后的 URL 片段。

                    总结: 使用encodeURI()编码整个url,而只使用encodeURIComponent()编码那些追加在已有url后面的字符串。
                </pre>
                <h5>4. URL实例对象的创建方法</h5>
                <pre>
                    URL()作为构造函数,可以生成 URL 实例。它接受一个表示 URL 的字符串作为参数。如果参数不是合法的 URL,会报错。
                    语法:
                        const url = new URL("字符串");
                        const url = new URL('http://www.example.com/index.html');
                    如果是相对路径则需要传入第二个表示绝对路径的参数
                        const url2 = new URL('page2.html', 'http://example.com/page1.html');
                        // "http://example.com/page2.html"
                </pre>  
                <h5>5. URL常用的实例属性</h5>
                <pre>
                    URL 实例的属性与location对象真的URL操作的相关属性名称和用法基本一致,也是用来返回当前 URL 的信息。
                    可以理解为location对象实现了一个 URL接口,所以具备了URL的实例属性。
                        1.URL.href:返回整个 URL
                        2.URL.protocol:返回协议,以冒号:结尾
                        3.URL.hostname:返回域名
                        4.URL.host:返回域名与端口,包含:号,默认的80和443端口会省略
                        5.URL.port:返回端口
                        6.URL.origin:返回协议、域名和端口
                        7.URL.pathname:返回路径,以斜杠/开头
                        8.URL.search:返回查询字符串,以问号?开头
                        9.URL.searchParams:返回一个URLSearchParams实例,该属性是Location对象没有的
                        10.URL.hash:返回片段识别符,以井号#开头
                        11.URL.password:返回域名前面的密码
                        12.URL.username:返回域名前面的用户名
                    这些属性里面,只有origin属性是只读的,其他属性都可写,并且会立即生效。

                    const url = new URL('http://user:passwd@www.example.com:4097/path/a.html?x=111#part1');
                        url.href // "http://user:passwd@www.example.com:4097/path/a.html?x=111#part1"
                        url.protocol // "http:"
                        url.hostname // "www.example.com"
                        url.host // "www.example.com:4097"
                        url.port // "4097"
                        url.origin // "http://www.example.com:4097"
                        url.pathname // "/path/a.html"
                        url.search // "?x=111"
                        url.searchParams // URLSearchParams {}
                        url.hash // "#part1"
                        url.password // "passwd"
                        url.username // "user"
                </pre>
            </div> 
            <h4>7. URLSearchParams对象</h4>
            <div>
                <h5>1.概述</h5>
                <p>
                    在处理URL时,比较常见的是获取其中的查询字符串,可以通过location对象的location.search属性,也可以通过浏览器原生提供的URLSearchParams对象。
                    URLSearchParams对象提供了一组标准的用来构造、解析和处理 URL查询字符串(即 URL 问号后面的部分)的API方法。
                    URLSearchParams会对查询字符串自动编码。
                </p>
                <h5>2.URLSearchParams实例的创建方法</h5>
                <p>
                    它是一个构造函数,创建实例方法如下:接收一个查询字符串参数,起首的问号?有没有都行,也可以是对应查询字符串的数组或对象。
                    // 方法一：传入字符串
                    var params = new URLSearchParams('?foo=1&bar=2');
                    // 等同于
                    var params = new URLSearchParams(document.location.search);
                    // 方法二：传入数组
                    var params = new URLSearchParams([['foo', 1], ['bar', 2]]);
                    // 方法三：传入对象
                    var params = new URLSearchParams({'foo' : 1 , 'bar' : 2});
                </p>
                <h5>3.URLSearchParams常用的实例方法</h5>
                <p>
                    1.toString()方法返回实例的字符串形式。
                    2.append()方法用来追加一个查询参数。它接受两个参数,第一个为键名,第二个为键值,没有返回值。不会识别是否键名已经存在照样添加。
                    3.delete()方法用来删除指定的查询参数。它接受键名作为参数。
                    4.has()方法返回一个布尔值,表示查询字符串是否包含指定的键名。
                    5.set()方法用来设置查询字符串的键值。它接受两个参数,第一个是键名,第二个是键值。如果是已经存在的键,键值会被改写,否则会被追加。
                    6.get()方法用来读取查询字符串里面的指定键。它接受键名作为参数。只返回第一个
                    7.getAll()方法返回一个数组,成员是指定键的所有键值。它接受键名作为参数。返回所有指定键名的值
                    遍历器方法都返回一个遍历器对象供for...of循环遍历。它们的区别在于:
                    8.keys()方法返回的是键名的遍历器,
                    9.values()方法返回的是键值的遍历器,
                    10.entries()返回的是键值对的遍历器。

                    var url = new URL('https://example.com?foo=1&bar=2');
                    var params = new URLSearchParams(url.search);
                    params.toString() // "foo=1&bar=2'
                    params.append('baz', 3);
                    params.toString() // "foo=1&bar=2&baz=3"
                    params.delete('bar');
                    params.toString() // "foo=1&baz=3"
                    params.has('bar') // false
                    params.has('baz') // true
                    params.set('foo', 2);
                    params.toString() // "foo=2&baz=3"

                    var params = new URLSearchParams('a=1&b=2');
                    for(var p of params.keys()) {
                    console.log(p);
                    }
                    // a
                    // b
                    for(var p of params.values()) {
                    console.log(p);
                    }
                    // 1
                    // 2
                    for(var p of params.entries()) {
                    console.log(p);
                    }
                    // ["a", "1"]
                    // ["b", "2"]
                </p>
            </div>
        </div>
    </div>

<!-- js -->
<script>
window.onload = function(){
    //window
    // console.log(window)
    // window.alert("hello alert")
    // alert("hi alert")
    // window.prompt('prompt方法',12)
    // window.confirm("确定删除吗？")

    //  Navigator对象
    // console.log(navigator)
    // console.log(navigator.appName);//Netscape
    // console.log(navigator.userAgent);//Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko/20100101 Firefox/66.0
    // 应用:检查插件 
    // console.log(window.navigator.plugins)
    // let hasPlugins = function(name){
    //     name =  name.toLowerCase()
    //     // 循环判断
    //     for(let plugin  of window.navigator.plugins){
    //         if(plugin.name.toLowerCase().indexOf(name) >  -1){
    //             return true
    //         }
    //     }
    //     return false
    // }
    // alert(hasPlugins('Flash'))
    // screen
    // console.log(screen)
    // console.log(screen.width)
    // console.log(screen.height)
    // console.log(screen.availWidth)
    // console.log(screen.availHeight)
     
    //history
    // console.log(history)
    // console.log(history.length)
    // history.go()
    // history.back()
    // history.forward()
    // history.pushState()
    // history.replaceState()


    // location
    // console.log(location);
    // console.log(location.href)//通过这个可以实现页面的跳转
    // console.log(location.origin)
    // console.log(location.protocol)
    // console.log(location.host)
    // console.log(location.hostname)
    // console.log(location.port)
    // console.log(location.pathname)
    // console.log(location.search)

    // location.assign() 	 加载 URL 指定的新的 HTML 文档。就相当于一个链接,跳转到指定的url,当前页面会转为新页面内容,可以点击后退返回上一个页面。
    // location.reload() 	 	重新载入当前文档
    // location.replace()	通过加载 URL 指定的文档来替换当前文档,这个方法是替换当前窗口页面,前后两个页面共用一个窗口,所以是没有后退返回上一页的

    // localStorage
    // console.log(localStorage)
    // localStorage.setItem("name","张三")
    // console.log(localStorage.getItem("name"))
    // console.log(localStorage)
    // console.log(sessionStorage)
    // sessionStorage.setItem("name","张三")
    // sessionStorage.getItem("name")

/*URL对象*/
    let url = new URL('http://user:passwd@www.example.com:4097/path/a.html?x=111#part1');
        
    url.href
    // "http://user:passwd@www.example.com:4097/path/a.html?x=111#part1"
    url.protocol
    // "http:"
    url.hostname
    // "www.example.com"
    url.host
    // "www.example.com:4097"
    url.port
    // "4097"
    url.origin
    // "http://www.example.com:4097"
    url.pathname
    // "/path/a.html"
    url.search
    // "?x=111"
    url.searchParams
    // URLSearchParams {}
    url.hash
    // "#part1"
    url.password
    // "passwd"
    url.username
    // "user"

   
};
</script>
</body>
</html>